// üåü AI Progression Elite - Sistema avanzado de progresi√≥n para IAs üåü
// Autor: Buchedegatito
// Fecha: 2025-05-21 22:20:27

// üéõÔ∏è Configuraci√≥n del sistema
AIP_Config = [
    0.2,  // Nivel inicial de habilidad (0.0 a 1.0)
    
    // üìä Rangos (de menor a mayor) y kills necesarias
    [
        "PRIVATE",   // Recluta - 0 kills
        "CORPORAL",  // Cabo - 3 kills
        "SERGEANT",  // Sargento - 9 kills
        "LIEUTENANT",// Teniente - 21 kills
        "CAPTAIN",   // Capit√°n - 45 kills
        "MAJOR",     // Mayor - 93 kills
        "COLONEL"    // Coronel - 189 kills
    ],
    
    // üéØ Multiplicadores de experiencia por tipo de kill
    [1.0, 2.0, 3.0], // Infanter√≠a, Veh√≠culos, A√©reos
    
    // üß† Configuraci√≥n de especialidades [Velocidad inicial, Mejora por acci√≥n, Acciones para mejorar]
    [
        [0.2, 0.01, 10], // M√©dico: velocidad curaci√≥n, mejora, n√∫mero curaciones
        [0.2, 0.01, 5],  // Ingeniero: velocidad reparaci√≥n, mejora, n√∫mero reparaciones
        [0.2, 0.02, 3]   // EOD: velocidad desactivaci√≥n, mejora, n√∫mero desactivaciones
    ]
];

// üìù Variables globales
AIP_UnitsTracked = [];    // Array para seguir unidades
AIP_Debug = false;        // Mensajes de depuraci√≥n desactivados
AIP_BonusPerRank = 0.5;   // Bonus de resistencia por rango (%)
AIP_EnableMorale = true;  // Sistema de moral habilitado
AIP_EnableSharedXP = true;// Experiencia compartida

// üöÄ Inicializar una unidad
AIP_InitUnit = {
    params ["_unit"];
    if (_unit getVariable ["AIP_Initialized", false]) exitWith {};
    
    // Variables b√°sicas
    _unit setVariable ["AIP_Initialized", true, true];
    _unit setVariable ["AIP_Kills", 0, true];
    _unit setVariable ["AIP_RankIndex", 0, true];
    _unit setVariable ["AIP_VehicleKills", 0, true];
    _unit setVariable ["AIP_AirKills", 0, true];
    _unit setVariable ["AIP_TimeAiming", 0, true];
    _unit setVariable ["AIP_DistanceRun", 0, true];
    _unit setVariable ["AIP_TimeInCombat", 0, true];
    _unit setVariable ["AIP_ReloadsPerformed", 0, true];
    _unit setVariable ["AIP_ShotsFired", 0, true];
    _unit setVariable ["AIP_HitsLanded", 0, true];
    _unit setVariable ["AIP_LastPosition", getPosATL _unit, true];
    _unit setVariable ["AIP_IsInCombat", false, true];
    _unit setVariable ["AIP_DamageReduction", 0, true];
    _unit setVariable ["AIP_Morale", 50, true];
    _unit setVariable ["AIP_Specialties", [], true];
    _unit setVariable ["AIP_FavoriteTerrain", [], true];
    _unit setVariable ["AIP_InPanic", false, true]; // Para controlar el estado de p√°nico
    
    // Preservar roles especiales
    if (_unit getUnitTrait "Medic") then {
        _unit setVariable ["AIP_IsMedic", true, true];
        _unit setVariable ["AIP_HealingSpeed", (AIP_Config select 3) select 0 select 0, true];
        _unit setVariable ["AIP_HealingPerformed", 0, true];
    };
    if (_unit getUnitTrait "Engineer") then {
        _unit setVariable ["AIP_IsEngineer", true, true];
        _unit setVariable ["AIP_RepairSpeed", (AIP_Config select 3) select 1 select 0, true];
        _unit setVariable ["AIP_RepairsPerformed", 0, true];
    };
    if (_unit getUnitTrait "ExplosiveSpecialist") then {
        _unit setVariable ["AIP_IsEOD", true, true];
        _unit setVariable ["AIP_DefuseSpeed", (AIP_Config select 3) select 2 select 0, true];
        _unit setVariable ["AIP_DefusalsPerformed", 0, true];
    };
    
    // Inicializar habilidades y rango
    [_unit] call AIP_SetInitialSkills;
    _unit setRank ((AIP_Config select 1) select 0);
    AIP_UnitsTracked pushBackUnique _unit;
    
    // Event handlers
    _unit addEventHandler ["Killed", AIP_EH_Killed];
    _unit addEventHandler ["FiredMan", AIP_EH_FiredMan];
    _unit addEventHandler ["Hit", AIP_EH_Hit];
    _unit addEventHandler ["Reloaded", AIP_EH_Reloaded];
    _unit addEventHandler ["HandleDamage", AIP_EH_HandleDamage];
};

// üíÄ Event Handler: Killed
AIP_EH_Killed = {
    params ["_unit", "_killer"];
    
    if (isPlayer _killer || !(_killer getVariable ["AIP_Initialized", false])) exitWith {};
    
    // Incrementar contadores
    [_killer, 1] call AIP_AddKill;
    
    // Moral
    [_killer, 5] call AIP_AdjustMorale;
    
    // Aliados cercanos pierden moral
    {
        if (_x != _killer && {side _x == side _unit} && {_x getVariable ["AIP_Initialized", false]}) then {
            [_x, -2] call AIP_AdjustMorale;
        };
    } forEach (_unit nearEntities ["Man", 30]);
    
    // Experiencia compartida
    if (AIP_EnableSharedXP) then {
        {
            if (_x != _killer && {side _x == side _killer} && {_x getVariable ["AIP_Initialized", false]}) then {
                [_x, 0.1] call AIP_AddKill;
            };
        } forEach (_killer nearEntities ["Man", 50]);
    };
};

// üî´ Event Handler: FiredMan (Disparo)
AIP_EH_FiredMan = {
    params ["_unit", "_weapon", "_muzzle", "_mode", "_ammo", "_magazine", "_projectile", "_vehicle"];
    
    // Incrementar contador de disparos
    _shotsFired = (_unit getVariable ["AIP_ShotsFired", 0]) + 1;
    _unit setVariable ["AIP_ShotsFired", _shotsFired, true];
    
    // Seguir el proyectil para ver impactos
    [_unit, _projectile] spawn {
        params ["_unit", "_projectile"];
        waitUntil {isNull _projectile};
        
        {
            if (_x getVariable ["AIP_HitBy", objNull] == _unit) then {
                // Contar impacto
                _hitsLanded = (_unit getVariable ["AIP_HitsLanded", 0]) + 1;
                _unit setVariable ["AIP_HitsLanded", _hitsLanded, true];
                
                // Destrucci√≥n de veh√≠culos
                if (!alive _x) then {
                    if (_x isKindOf "Air") then {
                        [_unit, 3] call AIP_AddKill;
                        _airKills = (_unit getVariable ["AIP_AirKills", 0]) + 1;
                        _unit setVariable ["AIP_AirKills", _airKills, true];
                        [_unit, 15] call AIP_AdjustMorale;
                    } else {
                        if (_x isKindOf "LandVehicle") then {
                            [_unit, 2] call AIP_AddKill;
                            _vehKills = (_unit getVariable ["AIP_VehicleKills", 0]) + 1;
                            _unit setVariable ["AIP_VehicleKills", _vehKills, true];
                            [_unit, 10] call AIP_AdjustMorale;
                        };
                    };
                };
                
                // Mejorar precisi√≥n si es buena
                if (_unit getVariable ["AIP_ShotsFired", 0] >= 10) then {
                    _shotsTotal = _unit getVariable ["AIP_ShotsFired", 0];
                    _hitsTotal = _unit getVariable ["AIP_HitsLanded", 0];
                    _accuracyRatio = _hitsTotal / _shotsTotal;
                    
                    if (_accuracyRatio > 0.7) then {
                        [_unit, "aimingAccuracy", 0.002] call AIP_ImproveSkill;
                        [_unit, "aimingShake", 0.001] call AIP_ImproveSkill;
                    };
                };
            };
        } forEach nearestObjects [getPos _unit, ["Man", "LandVehicle", "Air"], 150];
    };
};

// üéØ Event Handler: Hit (Impacto recibido)
AIP_EH_Hit = {
    params ["_unit", "_source", "_damage", "_instigator"];
    
    if (!isNull _instigator && !isPlayer _instigator && (_instigator getVariable ["AIP_Initialized", false])) then {
        _unit setVariable ["AIP_HitBy", _instigator, true];
        
        if (_unit getVariable ["AIP_Initialized", false]) then {
            [_unit, -1] call AIP_AdjustMorale;
        };
    };
};

// üîÑ Event Handler: Reloaded (Recarga)
AIP_EH_Reloaded = {
    params ["_unit", "_weapon", "_muzzle", "_newMagazine", "_oldMagazine"];
    
    if (_weapon == primaryWeapon _unit || _weapon == secondaryWeapon _unit || _weapon == handgunWeapon _unit) then {
        _reloads = (_unit getVariable ["AIP_ReloadsPerformed", 0]) + 1;
        _unit setVariable ["AIP_ReloadsPerformed", _reloads, true];
        
        if (_reloads % 5 == 0) then {
            [_unit, "reloadSpeed", 0.01] call AIP_ImproveSkill;
        };
    };
};

// üõ°Ô∏è Event Handler: HandleDamage (Recibir da√±o)
AIP_EH_HandleDamage = {
    params ["_unit", "_selection", "_damage", "_source", "_projectile", "_hitIndex", "_instigator", "_hitPoint"];
    
    if (_unit getVariable ["AIP_Initialized", false]) then {
        _damageReduction = _unit getVariable ["AIP_DamageReduction", 0];
        _moraleFactor = 1.0;
        
        if (AIP_EnableMorale) then {
            _morale = _unit getVariable ["AIP_Morale", 50];
            if (_morale < 25) then {
                _moraleFactor = 1.15;
            } else {
                if (_morale > 75) then {
                    _moraleFactor = 0.9;
                };
            };
        };
        
        if (_damageReduction > 0 || _moraleFactor != 1.0) then {
            _reducedDamage = _damage * (1 - (_damageReduction min 0.75)) * _moraleFactor;
            _reducedDamage
        } else {
            _damage
        };
    } else {
        _damage
    };
};

// üèÅ Establecer habilidades iniciales
AIP_SetInitialSkills = {
    params ["_unit"];
    
    _baseSkill = AIP_Config select 0;
    
    // Aplicar a todas las sub-habilidades
    _unit setSkill ["general", _baseSkill];
    _unit setSkill ["aimingAccuracy", _baseSkill];
    _unit setSkill ["aimingShake", _baseSkill];
    _unit setSkill ["aimingSpeed", _baseSkill];
    _unit setSkill ["endurance", _baseSkill];
    _unit setSkill ["spotDistance", _baseSkill];
    _unit setSkill ["spotTime", _baseSkill];
    _unit setSkill ["courage", _baseSkill];
    _unit setSkill ["reloadSpeed", _baseSkill];
    _unit setSkill ["commanding", _baseSkill];
    
    // Restaurar habilidades especializadas
    if (_unit getVariable ["AIP_IsMedic", false]) then { _unit setUnitTrait ["Medic", true]; };
    if (_unit getVariable ["AIP_IsEngineer", false]) then { _unit setUnitTrait ["Engineer", true]; };
    if (_unit getVariable ["AIP_IsEOD", false]) then { _unit setUnitTrait ["ExplosiveSpecialist", true]; };
};

// ‚¨ÜÔ∏è A√±adir una kill (con multiplicador)
AIP_AddKill = {
    params ["_unit", ["_multiplier", 1]];
    
    if (!alive _unit) exitWith {};
    
    // Incrementar contador de kills
    _kills = (_unit getVariable ["AIP_Kills", 0]) + 1;
    _unit setVariable ["AIP_Kills", _kills, true];
    
    // Mejorar habilidades con multiplicador
    [_unit, "aimingAccuracy", 0.01 * _multiplier] call AIP_ImproveSkill;
    [_unit, "aimingSpeed", 0.01 * _multiplier] call AIP_ImproveSkill;
    [_unit, "spotDistance", 0.01 * _multiplier] call AIP_ImproveSkill;
    [_unit, "spotTime", 0.01 * _multiplier] call AIP_ImproveSkill;
    
    // Verificar promoci√≥n y especialidades
    [_unit] call AIP_CheckPromotion;
    [_unit] call AIP_CheckEmergingSpecialties;
};

// üòÄ Ajustar nivel de moral
AIP_AdjustMorale = {
    params ["_unit", "_change"];
    
    if (!AIP_EnableMorale || !alive _unit) exitWith {};
    
    _currentMorale = _unit getVariable ["AIP_Morale", 50];
    _newMorale = (_currentMorale + _change) min 100 max 0;
    _unit setVariable ["AIP_Morale", _newMorale, true];
    
    // Efectos de moral extrema
    if (_newMorale <= 0 && _currentMorale > 0) then {
        // Moral a cero - p√°nico total
        [_unit] spawn {
            params ["_unit"];
            
            if (_unit getVariable ["AIP_InPanic", false]) exitWith {};
            _unit setVariable ["AIP_InPanic", true, true];
            
            // Soltar arma
            _weapon = primaryWeapon _unit;
            if (_weapon != "") then {
                _weaponHolder = "WeaponHolderSimulated" createVehicle (position _unit);
                _weaponHolder addWeaponCargoGlobal [_weapon, 1];
                
                // Remover arma
                _unit removeWeapon _weapon;
            };
            
            // Cambiar comportamiento
            _unit allowFleeing 1;
            _unit setCombatMode "BLUE";
            _unit setUnitPos "UP";
            
            // Animaci√≥n de p√°nico
            _unit playMoveNow "ApanPercMstpSnonWnonDnon_G01";
            
            // Correr a un lugar seguro
            _safePos = [];
            _attempts = 0;
            while {count _safePos == 0 && _attempts < 10} do {
                _randomDir = random 360;
                _distance = 50 + (random 50);
                _checkPos = [getPos _unit, _distance, _randomDir] call BIS_fnc_relPos;
                _safePos = _checkPos findEmptyPosition [1, 20, typeOf _unit];
                _attempts = _attempts + 1;
            };
            
            if (count _safePos == 0) then {
                _safePos = getPos _unit;
            };
            
            _unit doMove _safePos;
            
            // Esperar a que llegue
            waitUntil {unitReady _unit || !alive _unit};
            
            if (!alive _unit) exitWith {};
            
            // Animaci√≥n de esconderse
            _unit setUnitPos "DOWN";
            _unit playMoveNow "AmovPercMstpSnonWnonDnon_AmovPpneMstpSnonWnonDnon";
            sleep 2;
            _unit playMoveNow "ApanPpneMstpSnonWnonDnon_G01";
            
            // Mantenerlo escondido un tiempo
            sleep 60;
            
            if (!alive _unit) exitWith {};
            
            // Recuperarse gradualmente
            _unit setVariable ["AIP_InPanic", false, true];
            _unit setVariable ["AIP_Morale", 15, true]; // Recupera algo de moral
            _unit setUnitPos "AUTO";
            _unit allowFleeing 0.5;
            _unit setCombatMode "YELLOW";
        };
    } else {
        if (_newMorale < 15 && _currentMorale >= 15) then {
            // Moral muy baja - puede entrar en p√°nico
            if (random 100 < 30) then { // 30% chance
                _unit allowFleeing 1;
                _unit setCombatMode "BLUE";
            };
        } else {
            if (_newMorale > 85 && _currentMorale <= 85) then {
                // Moral muy alta - m√°s agresivo
                _unit allowFleeing 0;
                _unit setCombatMode "RED";
            } else {
                // Moral normal
                _unit allowFleeing 0.5;
            };
        };
    };
};

// üß© Verificar especialidades emergentes
AIP_CheckEmergingSpecialties = {
    params ["_unit"];
    
    _currentSpecs = _unit getVariable ["AIP_Specialties", []];
    _newSpecs = [];
    
    // üî≠ Francotirador
    if ((_unit skill "aimingAccuracy") > 0.7 && (_unit getVariable ["AIP_Kills", 0]) > 15) then {
        if (!("sniper" in _currentSpecs)) then {
            _newSpecs pushBack "sniper";
            [_unit, "aimingAccuracy", 0.05] call AIP_ImproveSkill;
            [_unit, "aimingShake", 0.05] call AIP_ImproveSkill;
        };
    };
    
    // üëÅÔ∏è Explorador
    if ((_unit skill "spotDistance") > 0.65 && (_unit getVariable ["AIP_DistanceRun", 0]) > 5000) then {
        if (!("scout" in _currentSpecs)) then {
            _newSpecs pushBack "scout";
            [_unit, "spotDistance", 0.07] call AIP_ImproveSkill;
            [_unit, "spotTime", 0.07] call AIP_ImproveSkill;
        };
    };
    
    // üí• Cazador de tanques
    if ((_unit getVariable ["AIP_VehicleKills", 0]) >= 3) then {
        if (!("AT" in _currentSpecs)) then {
            _newSpecs pushBack "AT";
            [_unit, "aimingAccuracy", 0.03] call AIP_ImproveSkill;
            [_unit, "courage", 0.05] call AIP_ImproveSkill;
        };
    };
    
    // Actualizar lista
    _unit setVariable ["AIP_Specialties", (_currentSpecs + _newSpecs), true];
};

// üìà Mejorar habilidad
AIP_ImproveSkill = {
    params ["_unit", "_skillName", "_increment"];
    _currentValue = _unit skill _skillName;
    _newValue = (_currentValue + _increment) min 1.0;
    _unit setSkill [_skillName, _newValue];
};

// ‚≠ê Verificar promoci√≥n
AIP_CheckPromotion = {
    params ["_unit"];
    
    _kills = _unit getVariable ["AIP_Kills", 0];
    _currentRankIndex = _unit getVariable ["AIP_RankIndex", 0];
    _newRankIndex = 0;
    
    // Calcular nuevo rango (3, 9, 21, 45, 93, 189)
    _thresholds = [0, 3, 9, 21, 45, 93, 189];
    for "_i" from 0 to (count _thresholds - 1) do {
        if (_kills >= _thresholds select _i) then { _newRankIndex = _i; };
    };
    
    if (_newRankIndex <= _currentRankIndex) exitWith {};
    
    // Actualizar rango
    _unit setVariable ["AIP_RankIndex", _newRankIndex, true];
    _rankName = (AIP_Config select 1) select _newRankIndex;
    _unit setRank _rankName;
    
    // Aumentar resistencia al da√±o
    _currentDamageReduction = _unit getVariable ["AIP_DamageReduction", 0];
    _newDamageReduction = _currentDamageReduction + (AIP_BonusPerRank * 0.01);
    _unit setVariable ["AIP_DamageReduction", _newDamageReduction, true];
    
    // Boost de moral y restaurar roles
    [_unit, 10] call AIP_AdjustMorale;
    if (_unit getVariable ["AIP_IsMedic", false]) then { _unit setUnitTrait ["Medic", true]; };
    if (_unit getVariable ["AIP_IsEngineer", false]) then { _unit setUnitTrait ["Engineer", true]; };
    if (_unit getVariable ["AIP_IsEOD", false]) then { _unit setUnitTrait ["ExplosiveSpecialist", true]; };
};

// ü©π Sistema de curaciones m√©dicas
AIP_CheckAndHealNearby = {
    {
        _medic = _x;
        if (alive _medic && {_medic getVariable ["AIP_IsMedic", false]}) then {
            if (!(_medic getVariable ["AIP_IsHealing", false])) then {
                _nearUnits = _medic nearEntities ["Man", 30];
                _wounded = [];
                
                {
                    if (damage _x > 0.1 && {side _x == side _medic}) then {
                        _wounded pushBack _x;
                    };
                } forEach _nearUnits;
                
                if (count _wounded > 0) then {
                    _targetToHeal = _wounded select 0;
                    _medic setVariable ["AIP_IsHealing", true, true];
                    _medic doMove (position _targetToHeal);
                    
                    [_medic, _targetToHeal] spawn {
                        params ["_medic", "_target"];
                        
                        waitUntil {_medic distance _target < 3 || !alive _medic || !alive _target};
                        
                        if (!alive _medic || !alive _target) exitWith {
                            _medic setVariable ["AIP_IsHealing", false, true];
                        };
                        
                        _medic doWatch _target;
                        _medic disableAI "MOVE";
                        _healingSpeed = _medic getVariable ["AIP_HealingSpeed", 0.2];
                        _healingTime = 10 * (1 - (_healingSpeed min 0.9));
                        
                        sleep _healingTime;
                        
                        if (alive _medic && alive _target) then {
                            _target setDamage 0;
                            _healCount = (_medic getVariable ["AIP_HealingPerformed", 0]) + 1;
                            _medic setVariable ["AIP_HealingPerformed", _healCount, true];
                            
                            if (_healCount % ((AIP_Config select 3) select 0 select 2) == 0) then {
                                _newSpeed = (_medic getVariable ["AIP_HealingSpeed", 0.2]) + ((AIP_Config select 3) select 0 select 1);
                                _medic setVariable ["AIP_HealingSpeed", _newSpeed min 0.9, true];
                            };
                            
                            [_medic, 2] call AIP_AdjustMorale;
                            [_target, 5] call AIP_AdjustMorale;
                        };
                        
                        _medic enableAI "MOVE";
                        _medic doFollow (leader group _medic);
                        _medic setVariable ["AIP_IsHealing", false, true];
                    };
                };
            };
        };
    } forEach AIP_UnitsTracked;
};

// üîß Sistema de reparaci√≥n de ingenieros
AIP_CheckAndRepairNearby = {
    {
        _engineer = _x;
        if (alive _engineer && {_engineer getVariable ["AIP_IsEngineer", false]}) then {
            if (!(_engineer getVariable ["AIP_IsRepairing", false])) then {
                _nearVehicles = _engineer nearEntities [["Car", "Tank", "Ship"], 50];
                _damaged = [];
                
                {
                    if ((damage _x > 0.1 || !canMove _x) && {side _x == side _engineer || side _x == civilian}) then {
                        _damaged pushBack _x;
                    };
                } forEach _nearVehicles;
                
                if (count _damaged > 0) then {
                    _vehicle = _damaged select 0;
                    _engineer setVariable ["AIP_IsRepairing", true, true];
                    _engineer doMove (position _vehicle);
                    
                    [_engineer, _vehicle] spawn {
                        params ["_engineer", "_vehicle"];
                        
                        waitUntil {_engineer distance _vehicle < 5 || !alive _engineer || !alive _vehicle};
                        
                        if (!alive _engineer || !alive _vehicle) exitWith {
                            _engineer setVariable ["AIP_IsRepairing", false, true];
                        };
                        
                        _engineer doWatch _vehicle;
                        _engineer disableAI "MOVE";
                        _repairSpeed = _engineer getVariable ["AIP_RepairSpeed", 0.2];
                        _repairTime = 20 * (1 - (_repairSpeed min 0.9));
                        
                        sleep _repairTime;
                        
                        if (alive _engineer && alive _vehicle) then {
                            _vehicle setDamage 0;
                            _vehicle setFuel 1;
                            _repairCount = (_engineer getVariable ["AIP_RepairsPerformed", 0]) + 1;
                            _engineer setVariable ["AIP_RepairsPerformed", _repairCount, true];
                            
                            if (_repairCount % ((AIP_Config select 3) select 1 select 2) == 0) then {
                                _newSpeed = (_engineer getVariable ["AIP_RepairSpeed", 0.2]) + ((AIP_Config select 3) select 1 select 1);
                                _engineer setVariable ["AIP_RepairSpeed", _newSpeed min 0.9, true];
                            };
                            
                            [_engineer, 3] call AIP_AdjustMorale;
                        };
                        
                        _engineer enableAI "MOVE";
                        _engineer doFollow (leader group _engineer);
                        _engineer setVariable ["AIP_IsRepairing", false, true];
                    };
                };
            };
        };
    } forEach AIP_UnitsTracked;
};

// üîÑ Actualizaci√≥n peri√≥dica de habilidades basada en acciones
AIP_UpdateSkillsBasedOnActions = {
    [] spawn {
        while {true} do {
            {
                _unit = _x;
                if (alive _unit) then {
                    // Estado de combate
                    _isInCombat = (behaviour _unit == "COMBAT" || combatMode _unit == "RED");
                    _unit setVariable ["AIP_IsInCombat", _isInCombat, true];
                    
                    // Distancia recorrida
                    _currentPos = getPosATL _unit;
                    _lastPos = _unit getVariable ["AIP_LastPosition", _currentPos];
                    _distance = _currentPos distance _lastPos;
                    
                    if (_distance > 5) then {
                        _totalDistance = (_unit getVariable ["AIP_DistanceRun", 0]) + _distance;
                        _unit setVariable ["AIP_LastPosition", _currentPos, true];
                        _unit setVariable ["AIP_DistanceRun", _totalDistance, true];
                        
                        // Mejorar resistencia con la distancia
                        _improvementInterval = 100 * (1 + floor (_totalDistance / 1000));
                        if (_totalDistance % _improvementInterval < _distance) then {
                            [_unit, "endurance", 0.005] call AIP_ImproveSkill;
                        };
                    };
                    
                    // Habilidades en combate
                    if (_isInCombat) then {
                        _combatTime = (_unit getVariable ["AIP_TimeInCombat", 0]) + 1;
                        _unit setVariable ["AIP_TimeInCombat", _combatTime, true];
                        
                        // Mejorar valor en combate
                        if (_combatTime % 60 == 0) then {
                            [_unit, "courage", 0.01] call AIP_ImproveSkill;
                        };
                        
                        // Mejorar punter√≠a si est√° apuntando
                        if ((stance _unit == "CROUCH" || stance _unit == "PRONE") && _unit call AIP_IsAiming) then {
                            _aimingTime = (_unit getVariable ["AIP_TimeAiming", 0]) + 1;
                            _unit setVariable ["AIP_TimeAiming", _aimingTime, true];
                            
                            if (_aimingTime % 20 == 0) then {
                                [_unit, "aimingShake", 0.005] call AIP_ImproveSkill;
                                [_unit, "aimingAccuracy", 0.005] call AIP_ImproveSkill;
                            };
                        };
                        
                        // Comandando para l√≠deres
                        if (leader (group _unit) == _unit && _combatTime % 120 == 0) then {
                            [_unit, "commanding", 0.01] call AIP_ImproveSkill;
                        };
                    };
                };
            } forEach AIP_UnitsTracked;
            
            // Procesar m√©dicos e ingenieros
            call AIP_CheckAndHealNearby;
            call AIP_CheckAndRepairNearby;
            
            sleep 1;
        };
    };
};

// üëÄ Comprobar si una unidad est√° apuntando
AIP_IsAiming = {
    private _unit = _this;
    private _weapon = currentWeapon _unit;
    
    if (_weapon == "") exitWith {false};
    
    private _anim = animationState _unit;
    private _isAiming = _anim find "aim" > -1 || 
                       {_anim find "Aim" > -1} || 
                       {_anim find "wait" > -1 && (_anim find "prone" > -1 || _anim find "crouch" > -1)};
    
    _isAiming
};

// üîç Monitoreo continuo para nuevas unidades
AIP_StartMonitoring = {
    [] spawn {
        while {true} do {
            {
                if (!isPlayer _x && {_x isKindOf "CAManBase"} && {side _x != civilian} && {!(_x getVariable ["AIP_Initialized", false])}) then {
                    [_x] call AIP_InitUnit;
                };
            } forEach allUnits;
            sleep 5;
        };
    };
};

// üìã Obtener informaci√≥n detallada de una unidad
AIP_GetUnitInfo = {
    params ["_unit"];
    
    if (!alive _unit) exitWith { hint "La unidad est√° muerta"; };
    
    // Obtener datos b√°sicos
    _kills = _unit getVariable ["AIP_Kills", 0];
    _vehKills = _unit getVariable ["AIP_VehicleKills", 0];
    _airKills = _unit getVariable ["AIP_AirKills", 0];
    _rankName = rank _unit;
    _damageReduction = (_unit getVariable ["AIP_DamageReduction", 0]) * 100;
    _morale = _unit getVariable ["AIP_Morale", 50];
    _specialties = _unit getVariable ["AIP_Specialties", []];
    
    // Habilidades
    _acc = (_unit skill "aimingAccuracy") * 100;
    _shake = (_unit skill "aimingShake") * 100;
    _speed = (_unit skill "aimingSpeed") * 100;
    _endur = (_unit skill "endurance") * 100;
    _spotD = (_unit skill "spotDistance") * 100;
    _spotT = (_unit skill "spotTime") * 100;
    _cour = (_unit skill "courage") * 100;
    _reload = (_unit skill "reloadSpeed") * 100;
    _command = (_unit skill "commanding") * 100;
    
    // Contadores de acci√≥n
    _distance = _unit getVariable ["AIP_DistanceRun", 0];
    _combatTime = _unit getVariable ["AIP_TimeInCombat", 0];
    _hits = _unit getVariable ["AIP_HitsLanded", 0];
    _shots = _unit getVariable ["AIP_ShotsFired", 0];
    _accuracy = if (_shots > 0) then {(_hits / _shots) * 100} else {0};
    
    // Roles especiales
    _roleInfo = [];
    
    if (_unit getVariable ["AIP_IsMedic", false]) then {
        _healSpeed = (_unit getVariable ["AIP_HealingSpeed", 0.2]) * 100;
        _healCount = _unit getVariable ["AIP_HealingPerformed", 0];
        _roleInfo pushBack format ["M√©dico (Vel: %1%2, Cur: %3)", _healSpeed toFixed 0, "%", _healCount];
    };
    
    if (_unit getVariable ["AIP_IsEngineer", false]) then {
        _repairSpeed = (_unit getVariable ["AIP_RepairSpeed", 0.2]) * 100;
        _repairCount = _unit getVariable ["AIP_RepairsPerformed", 0];
        _roleInfo pushBack format ["Ingeniero (Vel: %1%2, Rep: %3)", _repairSpeed toFixed 0, "%", _repairCount];
    };
    
    if (_unit getVariable ["AIP_IsEOD", false]) then {
        _defuseSpeed = (_unit getVariable ["AIP_DefuseSpeed", 0.2]) * 100;
        _defuseCount = _unit getVariable ["AIP_DefusalsPerformed", 0];
        _roleInfo pushBack format ["EOD (Vel: %1%2, Des: %3)", _defuseSpeed toFixed 0, "%", _defuseCount];
    };
    
    // Preparar el mensaje
    _message = format ["===== %1 (Rango: %2) =====\n", name _unit, _rankName];
    _message = _message + format ["Kills: Infanter√≠a %1 | Veh√≠culos %2 | A√©reos %3\n", _kills - (_vehKills + _airKills), _vehKills, _airKills];
    _message = _message + format ["Reducci√≥n da√±o: %1%% | Moral: %2%%\n", _damageReduction toFixed 1, _morale toFixed 0];
    _message = _message + format ["Precisi√≥n: %1%% | Resistencia: %2%% | Valor: %3%%\n", _acc toFixed 0, _endur toFixed 0, _cour toFixed 0];
    
    if (count _specialties > 0) then {
        _message = _message + format ["Especialidades: %1\n", _specialties joinString ", "];
    };
    
    {
        _message = _message + format ["Rol especial: %1\n", _x];
    } forEach _roleInfo;
    
    hint _message;
};

// üì± Inicializar monitoreo de moral
AIP_InitMoraleMonitoring = {
    // Monitorear muertes
    addMissionEventHandler ["EntityKilled", {
        params ["_killed", "_killer", "_instigator"];
        
        // Obtener lado de la unidad muerta
        _side = side _killed;
        
        // Si es un veh√≠culo o soldado de un lado espec√≠fico
        if (_side != civilian) then {
            // Buscar unidades cercanas del mismo lado
            {
                if (!isPlayer _x && {side _x == _side} && {_x getVariable ["AIP_Initialized", false]}) then {
                    // Calcular impacto moral
                    _distance = _killed distance _x;
                    if (_distance <= 150) then {
                        _moralImpact = 0;
                        
                        if (_killed isKindOf "Man") then {
                            // Aliado ca√≠do
                            _moralImpact = if (_distance < 20) then { -15 } else { -10 * (1 - (_distance / 150)) };
                        } else {
                            if (_killed isKindOf "Tank") then {
                                // Tanque destruido
                                _moralImpact = if (_distance < 30) then { -20 } else { -15 * (1 - (_distance / 150)) };
                            } else {
                                if (_killed isKindOf "Air") then {
                                    // Aeronave derribada
                                    _moralImpact = if (_distance < 50) then { -15 } else { -10 * (1 - (_distance / 150)) };
                                } else {
                                    if (_killed isKindOf "Car") then {
                                        // Veh√≠culo destruido
                                        _moralImpact = if (_distance < 30) then { -10 } else { -5 * (1 - (_distance / 150)) };
                                    };
                                };
                            };
                        };
                        
                        // Aplicar impacto moral
                        if (_moralImpact < 0) then {
                            [_x, _moralImpact] call AIP_AdjustMorale;
                        };
                    };
                };
            } forEach allUnits;
        };
    }];
};

// üéÆ A√±adir acciones para los jugadores
AIP_AddPlayerActions = {
    // Ver estad√≠sticas
    player addAction [
        "<img image='\A3\UI_F\data\IGUI\Cfg\Actions\talk_ca.paa' /> Ver estad√≠sticas de unidad", 
        {
            _targets = nearestObjects [player, ["Man"], 5];
            if (count _targets > 1) then {
                [_targets select 1] call AIP_GetUnitInfo;
            } else {
                hint "No hay unidades cercanas con sistema de progresi√≥n";
            };
        },
        nil, 1.5, true, true, "", "count (nearestObjects [player, ['Man'], 5]) > 1", 3
    ];
    
    // Llamar m√©dico
    player addAction [
        "<img image='\A3\UI_F\data\IGUI\Cfg\Actions\heal_ca.paa' /> Llamar m√©dico cercano", 
        {
            _medics = [];
            {
                if (!isPlayer _x && alive _x && side _x == side player && _x getVariable ["AIP_IsMedic", false]) then {
                    _medics pushBack _x;
                };
            } forEach (player nearEntities ["Man", 100]);
            
            if (count _medics > 0) then {
                _medic = _medics select 0;
                
                if !(_medic getVariable ["AIP_IsHealing", false]) then {
                    _medic setVariable ["AIP_IsHealing", true, true];
                    _medic doMove (position player);
                    
                    [_medic, player] spawn {
                        params ["_medic", "_player"];
                        
                        hint format ["M√©dico %1 acudiendo a tu posici√≥n...", name _medic];
                        waitUntil {_medic distance _player < 3 || !alive _medic};
                        
                        if (!alive _medic) exitWith {
                            hint "El m√©dico ha ca√≠do en combate";
                            _medic setVariable ["AIP_IsHealing", false, true];
                        };
                        
                        _medic doWatch _player;
                        _medic disableAI "MOVE";
                        _healingSpeed = _medic getVariable ["AIP_HealingSpeed", 0.2];
                        _healingTime = 10 * (1 - (_healingSpeed min 0.9));
                        
                        hint format ["%1 te est√° curando (%2s)", name _medic, _healingTime toFixed 1];
                        sleep _healingTime;
                        
                        if (alive _medic) then {
                            _player setDamage 0;
                            _healCount = (_medic getVariable ["AIP_HealingPerformed", 0]) + 1;
                            _medic setVariable ["AIP_HealingPerformed", _healCount, true];
                            
                            if (_healCount % ((AIP_Config select 3) select 0 select 2) == 0) then {
                                _newSpeed = (_medic getVariable ["AIP_HealingSpeed", 0.2]) + ((AIP_Config select 3) select 0 select 1);
                                _medic setVariable ["AIP_HealingSpeed", _newSpeed min 0.9, true];
                            };
                            
                            hint "Has sido curado completamente";
                            [_medic, 3] call AIP_AdjustMorale;
                        };
                        
                        _medic enableAI "MOVE";
                        _medic doFollow (leader group _medic);
                        _medic setVariable ["AIP_IsHealing", false, true];
                    };
                } else {
                    hint "El m√©dico m√°s cercano ya est√° ocupado";
                };
            } else {
                hint "No hay m√©dicos disponibles en las cercan√≠as";
            };
        },
        nil, 1.4, true, true, "", "damage player > 0.1", 3
    ];
    
    // Llamar ingeniero
    player addAction [
        "<img image='\A3\UI_F\data\IGUI\Cfg\Actions\repair_ca.paa' /> Llamar ingeniero para reparar veh√≠culo", 
        {
            _vehicles = [];
            {
                if (_x isKindOf "Car" || _x isKindOf "Tank" || _x isKindOf "Ship") then {
                    if (damage _x > 0.1 || !canMove _x) then {
                        _vehicles pushBack _x;
                    };
                };
            } forEach (nearestObjects [player, ["AllVehicles"], 10]);
            
            if (count _vehicles > 0) then {
                _vehicle = _vehicles select 0;
                
                _engineers = [];
                {
                    if (!isPlayer _x && {alive _x} && {side _x == side player} && {_x getVariable ["AIP_IsEngineer", false]}) then {
                        _engineers pushBack _x;
                    };
                } forEach (player nearEntities ["Man", 100]);
                
                if (count _engineers > 0) then {
                    _nearestEngineer = _engineers select 0;
                    
                    if !(_nearestEngineer getVariable ["AIP_IsRepairing", false]) then {
                        _nearestEngineer setVariable ["AIP_IsRepairing", true, true];
                        
                        // Mover al ingeniero hacia el veh√≠culo
                        _nearestEngineer doMove (position _vehicle);
                        
                        // Proceso de reparaci√≥n
                        [_nearestEngineer, _vehicle] spawn {
                            params ["_engineer", "_vehicle"];
                            
                            hint format ["Ingeniero %1 acudiendo a reparar el veh√≠culo...", name _engineer];
                            
                            // Esperar a que llegue cerca
                            waitUntil {_engineer distance _vehicle < 5 || !alive _engineer || !alive _vehicle};
                            
                            if (!alive _engineer) exitWith {
                                hint "El ingeniero ha ca√≠do en combate";
                                _engineer setVariable ["AIP_IsRepairing", false, true];
                            };
                            
                            if (!alive _vehicle) exitWith {
                                hint "El veh√≠culo ha sido destruido";
                                _engineer setVariable ["AIP_IsRepairing", false, true];
                            };
                            
                            // Detener movimiento
                            _engineer doWatch _vehicle;
                            _engineer disableAI "MOVE";
                            
                            // Comprobar velocidad de reparaci√≥n
                            _repairSpeed = _engineer getVariable ["AIP_RepairSpeed", 0.2];
                            _repairTime = 20 * (1 - (_repairSpeed min 0.9)); // Entre 2 y 20 segundos
                            
                            // Reparaci√≥n
                            hint format ["%1 est√° reparando el veh√≠culo (tiempo: %2s)", name _engineer, _repairTime toFixed 1];
                            
                            sleep _repairTime;
                            
                            if (alive _engineer && alive _vehicle) then {
                                // Reparar
                                _vehicle setDamage 0;
                                _vehicle setFuel 1;
                                
                                // Incrementar contador
                                _repairCount = (_engineer getVariable ["AIP_RepairsPerformed", 0]) + 1;
                                _engineer setVariable ["AIP_RepairsPerformed", _repairCount, true];
                                
                                // Mejorar habilidad de reparaci√≥n
                                if (_repairCount % ((AIP_Config select 3) select 1 select 2) == 0) then {
                                    _newSpeed = (_engineer getVariable ["AIP_RepairSpeed", 0.2]) + ((AIP_Config select 3) select 1 select 1);
                                    _engineer setVariable ["AIP_RepairSpeed", _newSpeed min 0.9, true];
                                };
                                
                                hint "El veh√≠culo ha sido reparado completamente";
                                
                                // Boost de moral
                                [_engineer, 3] call AIP_AdjustMorale;
                            };
                            
                            // Restaurar movimiento
                            _engineer enableAI "MOVE";
                            _engineer doFollow (leader group _engineer);
                            _engineer setVariable ["AIP_IsRepairing", false, true];
                        };
                    } else {
                        hint "El ingeniero m√°s cercano ya est√° ocupado";
                    };
                } else {
                    hint "No hay ingenieros disponibles en las cercan√≠as";
                };
            } else {
                hint "No hay veh√≠culos da√±ados cerca";
            };
        },
        nil,
        1.3,
        true,
        true,
        "",
        "count (nearestObjects [player, ['Car', 'Tank', 'Ship'], 10]) > 0",
        3
    ];
};

// Inicializar todas las unidades existentes
AIP_InitAllAI = {
    {
        if (!isPlayer _x && {_x isKindOf "CAManBase"} && {side _x != civilian} && {!(_x getVariable ["AIP_Initialized", false])}) then {
            [_x] call AIP_InitUnit;
        };
    } forEach allUnits;
};

// üöÄ Iniciar todo el sistema
AIP_Initialize = {
    // Inicializar unidades existentes
    call AIP_InitAllAI;
    
    // Iniciar monitoreo de nuevas unidades
    call AIP_StartMonitoring;
    
    // Iniciar monitoreo de moral
    call AIP_InitMoraleMonitoring;
    
    // Iniciar sistema de mejora de habilidades basado en acciones
    call AIP_UpdateSkillsBasedOnActions;
    
    // A√±adir acciones para el jugador
    call AIP_AddPlayerActions;
};

// üö¶ Iniciar el sistema
call AIP_Initialize;
