/*
    üåü Script: Naturaleza
    üë®‚Äçüíª Autor: Vianna & Enkeli
    üìÖ Creaci√≥n: 2025-05-18
    üé® Descripci√≥n: Sistema optimizado de efectos visuales de la naturaleza para Arma 3
*/

// ‚ö†Ô∏è Salida temprana si no hay interfaz
if (!hasInterface) exitWith {};

// üå≥ SECCI√ìN 1: ESCALADO DE VEGETACI√ìN 
// ==============================================
private _radius = worldSize * 2; // Radio aumentado para cubrir todo el mapa

private _scales = [
    ["TREE", [1.01, 1.03, 1.05]],  // Escala para √°rboles (m√≠n, m√°x, probabilidad media)
    ["BUSH", [0.8, 1.0, 1.5]],     // Escala para arbustos
	["small rock", 1.2],
    ["ruin", 1.1],
	["t_cocos_bend_f.p3d", [1.01, 1.03, 1.05]],
    ["t_cocos_small_f.p3d", [1.01, 1.03, 1.05]],
    ["t_cocos_tall_f.p3d", [1.01, 1.03, 1.05]],
    ["t_ficus_big_f.p3d", [1.01, 1.03, 1.05]],
    ["t_ficus_small_f.p3d", [1.01, 1.03, 1.05]],
    ["t_ficus_tall_f.p3d", [1.01, 1.03, 1.05]],
    ["t_pinus_s1_f.p3d", [1.01, 1.03, 1.05]],
    ["t_pinus_s2_f.p3d", [1.01, 1.03, 1.05]],
    ["t_pinus_s3_f.p3d", [1.01, 1.03, 1.05]],
    ["t_pinus_s4_f.p3d", [1.01, 1.03, 1.05]]
];

// Recolectar jugadores o usar el jugador local si est√° vac√≠o
private _allPlayers = allPlayers;
if (_allPlayers isEqualTo []) then {
    _allPlayers = [player];
};

// Contenedor para almacenar los nuevos objetos
private _newObjects = [];

// Procesar para cada jugador
{
    private _center = getPosATL _x;

    {
        private _type = _x select 0;
        private _scaleRange = _x select 1;

        // Buscar objetos dependiendo del tipo
        private _objects = nearestTerrainObjects [_center, [_type], _radius, false];

        // Crear nuevos objetos escalados
        {
            // Generar escala aleatoria dentro del rango definido
            private _factor = random [_scaleRange select 0, _scaleRange select 2, _scaleRange select 1]; 
            private _originalPos = getPosATL _x;
            private _originalDir = getDir _x;

            // Ajustar posici√≥n inicial para crear el nuevo objeto
            _originalPos set [2, 0]; // Asegurar que la posici√≥n inicial est√© en el suelo

            // Crear un objeto simple con el mismo modelo
            private _newObject = createSimpleObject [(getModelInfo _x) select 1, _originalPos];
            _newObject setObjectScale _factor;

            // Ajustar la posici√≥n seg√∫n la altura del terreno
            private _newPos = getPosATL _newObject;
            _newPos set [2, ((getPosWorld _newObject) select 2)];
            _newObject setPosATL _newPos;

            // Orientar el nuevo objeto y ocultar el original
            _newObject setDir _originalDir;
            _x hideObject true;

            // Guardar el nuevo objeto
            _newObjects pushBack _newObject;

        } forEach _objects;

    } forEach _scales;

} forEach _allPlayers;


// üîç SECCI√ìN 2: DETECCI√ìN DE √ÅRBOLES 
// ==============================================
// Funci√≥n para verificar si es una palmera
isPalmTree = {
    params ["_tree"];
    private _isPalm = false;
    private _modelName = getText(configFile >> "CfgVehicles" >> typeOf _tree >> "model");
    private _className = typeOf _tree;
    
    if (_modelName find "palm" > -1 || 
        _modelName find "Palm" > -1 || 
        _modelName find "PALM" > -1 ||
        _className find "palm" > -1 ||
        _className find "Palm" > -1 ||
        _className find "PALM" > -1) then {
        _isPalm = true;
    };
    
    _isPalm
};


// ‚ú® SECCI√ìN 3: SISTEMA DE PART√çCULAS AMBIENTALES
// ==============================================
[] spawn {
    private ["_dustPS", "_dustActive", "_dustLevel", "_pos", "_inHouse", 
             "_urbanObjs", "_inTown", "_drop", "_nearTrees", "_inForest",
             "_treeObjects", "_processedTrees", "_sizeVariation", "_selectedColor"];
    
    _dustPS = objNull;
    _dustActive = false;
    _dustLevel = 0;
    
    // Array de colores regulares (para interiores y zonas urbanas)
    private _regularColors = [
        // Blanco
        [
            [1.0, 1.0, 1.0, 0],
            [1.0, 1.0, 1.0, 0.8],
            [1.0, 1.0, 1.0, 0]
        ],
        // Caf√© claro
        [
            [0.8, 0.6, 0.4, 0],
            [0.8, 0.6, 0.4, 0.8],
            [0.8, 0.6, 0.4, 0]
        ],
        // Caf√© oscuro
        [
            [0.4, 0.3, 0.2, 0],
            [0.4, 0.3, 0.2, 0.8],
            [0.4, 0.3, 0.2, 0]
        ],
        // Gris
        [
            [0.5, 0.5, 0.5, 0],
            [0.5, 0.5, 0.5, 0.8],
            [0.5, 0.5, 0.5, 0]
        ]
    ];
    
    // Array de colores SOLO para bosques (m√°s brillantes)
    private _forestColors = [
        // Blanco brillante
        [
            [1.0, 1.0, 1.0, 0],
            [1.0, 1.0, 1.0, 1.0],  // Mayor alfa para m√°s brillo
            [1.0, 1.0, 1.0, 0]
        ],
        // Amarillo
        [
            [1.0, 0.9, 0.2, 0],
            [1.0, 0.9, 0.2, 1.0],  // Amarillo brillante
            [1.0, 0.9, 0.2, 0]
        ],
        // Verde
        [
            [0.3, 0.8, 0.2, 0],
            [0.3, 0.8, 0.2, 1.0],  // Verde brillante
            [0.3, 0.8, 0.2, 0]
        ],
        // Caf√© oscuro
        [
            [0.4, 0.3, 0.2, 0],
            [0.4, 0.3, 0.2, 1.0],  // Mayor alfa para m√°s brillo
            [0.4, 0.3, 0.2, 0]
        ]
    ];

    while {true} do {
        sleep 1;

        _pos = getPosATL player;
        _inHouse = count (player nearObjects ["House", 8]) > 0;

        // üå≤ DETECCI√ìN DE BOSQUE MEJORADA
        _nearTrees = nearestTerrainObjects [_pos, ["Tree"], 30, false];
        
        _treeObjects = nearestObjects [_pos, ["Land_TreeBin_F", "Land_Tree_01_F", "Land_Tree_02_F", 
                                            "Land_Tree_03_F", "Land_Tree_04_F", "Land_Tree_05_F", 
                                            "Land_Woods_Pine_Tall", "Land_Woods_Tree_Birch", "Land_Woods_Tree_Pine"], 30];
        
        // Tambi√©n verificar si hay √°rboles no-palmeras
        _processedTrees = [];
        {
            if (!([_x] call isPalmTree)) then {
                _processedTrees pushBack _x;
            };
        } forEach (_nearTrees + _treeObjects);
        
        // Requiere al menos 3 √°rboles para considerar bosque
        _inForest = (count _processedTrees) >= 3;
        
        // Determinar entorno urbano
        _urbanObjs = player nearObjects ["Building", 10];
        _inTown = {!(_x isKindOf "House")} count _urbanObjs > 4;

        // Determinar nivel de polvo
        _dustLevel = if (_inForest) then {2} else {
            if (_inHouse) then {1} else {
                if (_inTown) then {1} else {0};
            }
        };

        // Activar efecto si aplica
        if (_dustLevel > 0 && !_dustActive) then {
            _dustActive = true;

            _drop = switch (_dustLevel) do {
                case 1: {0.20};  // m√≠nimo
                case 2: {1.00};  // denso en bosque
                default {0.10};
            };

            _dustPS = "#particlesource" createVehicleLocal _pos;
            _dustPS setParticleCircle [0,[0,0,0]];
            
            // Configuraci√≥n de aleatoriedad
            _dustPS setParticleRandom [
                5,                      // tiempo de vida
                [1,1,3],                // posici√≥n
                [0,0,0],                // velocidad
                0,                      // rotaci√≥n
                0.005,                  // peso
                [0,0,0,0.3],            // color (alpha)
                0.2,                    // direcci√≥n
                0.02                    // tama√±o
            ];
            
            // Seleccionar color y tama√±o seg√∫n el entorno
            if (_inForest) then {
                // BOSQUE: colores espec√≠ficos y part√≠culas m√°s grandes (doble del exterior + un poco extra)
                _selectedColor = selectRandom _forestColors;
                // Tama√±o original √ó 4 √ó 1.25 (un poco extra para bosque)
                _sizeVariation = random [0.02, 0.032, 0.05]; 
            } else {
                if (_inHouse) then {
                    // INTERIOR: tama√±o doble del original
                    _selectedColor = selectRandom _regularColors;
                    _sizeVariation = random [0.014, 0.02, 0.03]; // El doble del tama√±o original
                } else {
                    // EXTERIOR: tama√±o cu√°druple del original (doble del doble)
                    _selectedColor = selectRandom _regularColors;
                    _sizeVariation = random [0.028, 0.04, 0.06]; // Cuatro veces m√°s grande
                };
            };
            
            _dustPS setParticleParams [
                ["\A3\data_f\kouleSvetlo",1,0,1], "", "Billboard",
                1, 10, [0,0,2], [0,0,0],
                0, 10.08, 7.9, 0,
                [_sizeVariation * 0.8, _sizeVariation, _sizeVariation * 0.8],  // Tama√±o variable
                _selectedColor,  // Color seleccionado seg√∫n entorno
                [0.08], 0.5, 0.01, "", "", player
            ];
            
            _dustPS setDropInterval _drop;
            
            // Asegurar que las part√≠culas sigan al jugador
            [_dustPS] spawn {
                private ["_ps"];
                params ["_ps"];
                while {!isNull _ps} do {
                    _ps setPosATL (getPosATL player);
                    sleep 0.5;
                };
            };
        };

        // Desactivar si se sale de zona v√°lida
        if (_dustLevel == 0 && _dustActive) then {
            _dustActive = false;
            if (!isNull _dustPS) then { deleteVehicle _dustPS; };
        };
    };
};

// üå¨Ô∏è SECCI√ìN 4: EFECTOS DE VIENTO
// ==============================================
// CONFIGURACI√ìN - MODIFICA ESTOS VALORES PARA AJUSTAR INTENSIDAD
VIENTO_INTENSIDAD = 0.1;      // [AJUSTAR] Velocidad del viento (1=bajo, 5=fuerte)
POLVO_INTENSIDAD = 0.0030;    // [AJUSTAR] Visibilidad del polvo (0.02=sutil, 0.2=intenso)
HOJAS_CANTIDAD = 0.6;         // [AJUSTAR] Densidad de hojas (0.05=pocas, 0.01=muchas)
HOJAS_VELOCIDAD = 1.0;        // [AJUSTAR] Velocidad de hojas (0.8=lento, 2.5=r√°pido)

// CONFIGURACI√ìN TEMPORAL - INTERVALOS DE APARICI√ìN
TIEMPO_ACTIVACION = 12;       // Duraci√≥n de cada r√°faga de viento (en segundos)
INTERVALO_PRINCIPAL = 120;    // Cada cu√°nto aparecen las r√°fagas (15 min = 900 segundos)
REPETICIONES_POR_CICLO = 6;   // N√∫mero de r√°fagas seguidas
INTERVALO_ENTRE_RAFAGAS = 10; // Segundos entre cada r√°faga del mismo ciclo

// OPTIMIZACI√ìN DE RENDIMIENTO
DISTANCIA_MAXIMA = 50;       // [RENDIMIENTO] M√°xima distancia a la que se ven efectos (metros)
MODO_RENDIMIENTO = true;     // [RENDIMIENTO] Activar modo de rendimiento optimizado
USAR_MENSAJES = true;        // [RENDIMIENTO] Mostrar mensajes de sistema (desactivar para FPS)

// Funci√≥n para detectar si est√°s dentro de edificio (por Killzone Kid)
KK_fnc_inHouse = {
    _house = lineIntersectsSurfaces [getPosWorld _this, getPosWorld _this vectorAdd [0, 0, 50], _this, objNull, true, 1, "GEOM", "NONE"];
    if (count _house == 0) exitWith {false};
    if (((_house select 0) select 3) isKindOf "house") exitWith {true};
    false
};

// Funci√≥n principal de efectos de viento (optimizada)
fnc_crear_efectos_viento = {
    // Comprobar rendimiento actual
    if (MODO_RENDIMIENTO && diag_fps < 20) exitWith {
        if (USAR_MENSAJES) then {systemChat ""};
    };
    
    // Comprobar si el jugador est√° dentro de un edificio
    _en_interior = player call KK_fnc_inHouse;
    
    // Solo crear efectos si est√° en exterior
    if (!_en_interior) then {
        // Color y alpha del polvo
        _color = [1.0, 0.9, 0.8];
        _alpha = POLVO_INTENSIDAD;
        
        // Vector de velocidad del viento 
        _velocidad_viento = [VIENTO_INTENSIDAD, VIENTO_INTENSIDAD * 0.2, 0];
        
        // Determinar nivel de detalle seg√∫n FPS
        _fps_actual = diag_fps;
        _factor_optimizacion = 1;
        
        // Ajustar detalle seg√∫n FPS
        if (_fps_actual < 30) then {_factor_optimizacion = 0.5};
        if (_fps_actual < 20) then {_factor_optimizacion = 0.3};
        
        // üí® EFECTO 1: POLVO
        _dust_particles = "#particlesource" createVehiclelocal (getPos player);
        if (vehicle player != player) then {
            _dust_particles attachto [vehicle player, [0, -10, 0]];
        } else {
            _dust_particles attachto [player, [0, -10, 0]];
        };
        
        _dust_particles setParticleCircle [15, [0, 0, 0]];
        _dust_particles setParticleRandom [3, [5, 5, 0], [0, 0, 0], 1, 0, [0, 0, 0, 0.01], 0, 0];
        _dust_particles setParticleParams [
            ["\A3\data_f\cl_basic", 1, 0, 1], 
            "", 
            "Billboard", 
            1, 
            5, 
            [0, 0, 0], 
            _velocidad_viento, 
            13, 
            10, 
            8, 
            1, 
            [2, 6, 10], 
            [_color + [0], _color + [_alpha], _color + [0]], 
            [0.08], 
            1, 
            0, 
            "", 
            "", 
            vehicle player,
            DISTANCIA_MAXIMA      // A√±adir l√≠mite de distancia para rendimiento
        ];
        
        // Ajustar cantidad de part√≠culas seg√∫n rendimiento
        _dust_particles setDropInterval (0.01 / _factor_optimizacion);
        
        // üçÉ EFECTO 2: HOJAS (SOLO SI FPS SUFICIENTES)
        _leaves_particles = objNull;
        if (_fps_actual > 25) then {
            _leaves_particles = "#particlesource" createVehicleLocal (getpos player);
            if (vehicle player != player) then {
                _leaves_particles attachto [vehicle player, [0, 0, 5]];
            } else {
                _leaves_particles attachto [player, [0, 0, 5]];
            };
            
            _leaves_particles setParticleCircle [15, [1, 1, 0]];
            _leaves_particles setParticleRandom [
                0, 
                [10, 10, 3], 
                [
                    -(_velocidad_viento select 1) * HOJAS_VELOCIDAD,
                    -(_velocidad_viento select 0) * HOJAS_VELOCIDAD,
                    0
                ], 
                0.2, 
                0.01, 
                [0, 0, 0, 0.1], 
                0.5, 
                0.5
            ];
            _leaves_particles setParticleParams [
                ["\A3\data_f\ParticleEffects\Hit_Leaves\Leaves_Green.p3d", 1, 0, 1],
                "",
                "SpaceObject",
                1,
                7,
                [0, 0, 2],
                [
                    (_velocidad_viento select 1) * HOJAS_VELOCIDAD,
                    (_velocidad_viento select 0) * HOJAS_VELOCIDAD,
                    0
                ],
                7,
                0.15,
                0.1,
                1,
                [1 + random 1],
                [[0.68, 0.68, 0.68, 1]],
                [0, 1],
                0.2,
                1.2,
                "",
                "",
                vehicle player,
                DISTANCIA_MAXIMA
            ];
            
            // Reducir cantidad de hojas para mejorar rendimiento
            _leaves_particles setDropInterval (HOJAS_CANTIDAD / _factor_optimizacion);
        };
        
        // Guardar part√≠culas en variables p√∫blicas para limpiarlas despu√©s
        player setVariable ["efectos_viento_polvo", _dust_particles];
        player setVariable ["efectos_viento_hojas", _leaves_particles];
        
        // Avisar al jugador (opcional)
        if (USAR_MENSAJES) then {systemChat ""};
    };
};

// Funci√≥n para limpiar efectos anteriores
fnc_limpiar_efectos_viento = {
    // Eliminar polvo si existe
    _dust_old = player getVariable ["efectos_viento_polvo", objNull];
    if (!isNull _dust_old) then {
        deleteVehicle _dust_old;
    };
    
    // Eliminar hojas si existen
    _leaves_old = player getVariable ["efectos_viento_hojas", objNull];
    if (!isNull _leaves_old) then {
        deleteVehicle _leaves_old;
    };
};

// Funci√≥n para activar una secuencia de r√°fagas de viento
fnc_ciclo_rafagas = {
    // Repetir la cantidad especificada de r√°fagas por ciclo
    for "_i" from 1 to REPETICIONES_POR_CICLO do {
        // Crear efectos
        call fnc_crear_efectos_viento;
        
        // Mantener efectos durante el tiempo especificado
        sleep TIEMPO_ACTIVACION;
        
        // Limpiar efectos
        call fnc_limpiar_efectos_viento;
        
        // Avisar del fin de la r√°faga (opcional)
        if (USAR_MENSAJES) then {systemChat ""};
        
        // Si no es la √∫ltima r√°faga del ciclo, esperar antes de la siguiente
        if (_i < REPETICIONES_POR_CICLO) then {
            sleep INTERVALO_ENTRE_RAFAGAS;
        };
    };
};

// Inicializar sistema de r√°fagas peri√≥dicas
[] spawn {
    waitUntil {!isNull player};
    sleep 3; // Esperar un poco para que todo cargue
    
    // Mostrar al inicio para pruebas (una √∫nica r√°faga)
    if (USAR_MENSAJES) then {
        systemChat "";
        systemChat "";
    };
    
    // Crear r√°faga inicial de prueba
    call fnc_crear_efectos_viento;
    sleep TIEMPO_ACTIVACION;
    call fnc_limpiar_efectos_viento;
    
    if (USAR_MENSAJES) then {
        systemChat "";
    };
    
    // Bucle principal (cada 15 minutos = 900 segundos)
    while {true} do {
        // Esperar hasta el pr√≥ximo ciclo
        sleep INTERVALO_PRINCIPAL;
        
        // Ejecutar un ciclo completo de r√°fagas
        call fnc_ciclo_rafagas;
        
        // Avisar del pr√≥ximo ciclo
        if (USAR_MENSAJES) then {
            systemChat format [];
        };
    };
};


/*
    üèôÔ∏è CIUDADES VIVAS v3.0 - SCRIPT OPTIMIZADO üèôÔ∏è
    üéÆ Mejoras Urbanas para Arma 3
    üîß Versi√≥n 3.0 - 2025-05-19
    ‚ú® Objetos urbanos y costeros
*/

// ‚ö†Ô∏è Salida temprana si no hay interfaz
if (!hasInterface) exitWith {};

// =============================================
// üìã CONFIGURACI√ìN GENERAL
// =============================================

// Par√°metros ajustables para rendimiento
CIUDAD_CONFIG = [
    300,    // 0: Radio de detecci√≥n en metros
    15,     // 1: M√°ximo luces en ventanas
    20,     // 2: M√°ximo objetos urbanos (basura, etc.)
    10,     // 3: M√°ximo puntos de sonido
    12,     // 4: M√°ximo objetos basura peque√±os
    15,     // 5: M√°ximo objetos de playa
    8,      // 6: M√°ximo flores/plantas decorativas
    0.8     // 7: Factor de brillo (0.5-1.0)
];

// Variables globales
CIUDAD_initialized = false;
CIUDAD_activo = false;
CIUDAD_luces = [];
CIUDAD_sonidos = [];
CIUDAD_objetos = [];
CIUDAD_objetosPlaya = [];
CIUDAD_flores = [];
CIUDAD_basuraPequena = [];
CIUDAD_triggers = [];

// =============================================
// üîç DETECCI√ìN DE ZONAS
// =============================================

// Funci√≥n para detectar ciudades
CIUDAD_fnc_detectarCiudad = {
    private _posJugador = getPosATL player;
    private _radio = CIUDAD_CONFIG select 0;
    
    // Contar edificios cercanos para determinar si es zona urbana
    private _edificios = nearestObjects [_posJugador, ["House", "Building"], _radio];
    private _calles = _posJugador nearRoads (_radio * 0.6);
    
    // Necesitamos suficientes edificios Y calles para considerar zona urbana
    private _esUrbano = (count _edificios > 12 && count _calles > 5);
    
    // Verificar si estamos cerca de costa
    private _esPlaya = false;
    if (_esUrbano) then {
        // Buscar playa cerca
        for "_d" from 20 to 150 step 30 do {
            for "_a" from 0 to 330 step 30 do {
                private _checkPos = [
                    (_posJugador select 0) + (_d * sin _a),
                    (_posJugador select 1) + (_d * cos _a),
                    0
                ];
                // Verificar si el terreno es playa o costa
                private _superficie = surfaceType _checkPos;
                if (["sand", _superficie] call BIS_fnc_inString || 
                    ["beach", _superficie] call BIS_fnc_inString || 
                    ["coast", _superficie] call BIS_fnc_inString) exitWith {
                    _esPlaya = true;
                };
            };
            if (_esPlaya) exitWith {};
        };
    };
    
    // Devolver resultado y datos
    [_esUrbano, _esPlaya, _edificios, _calles]
};

// =============================================
// üí° SISTEMA DE LUCES DIN√ÅMICAS
// =============================================

// Funci√≥n para crear luces en ventanas
CIUDAD_fnc_crearLuces = {
    params ["_edificios"];
    
    private _maxLuces = CIUDAD_CONFIG select 1;
    private _factorBrillo = CIUDAD_CONFIG select 7;
    private _lucesCreadas = 0;
    
    // Asegurarse que hay suficientes edificios
    if (count _edificios < 5) exitWith {};
    
    // Filtrar edificios grandes
    private _edificiosGrandes = _edificios select {
        private _box = boundingBox _x;
        private _altura = abs((_box select 1 select 2) - (_box select 0 select 2));
        _altura > 4
    };
    
    // Si no hay edificios grandes, usar cualquiera
    if (count _edificiosGrandes < 3) then {
        _edificiosGrandes = _edificios;
    };
    
    // Limitar cantidad
    if (count _edificiosGrandes > 25) then {
        _edificiosGrandes resize 25;
    };
    
    // Ordenar aleatoriamente
    _edificiosGrandes = _edificiosGrandes call BIS_fnc_arrayShuffle;
    
    {
        // Limitar n√∫mero total
        if (_lucesCreadas >= _maxLuces) exitWith {};
        
        // Solo procesar algunos edificios (30%)
        if (random 1 < 0.3) then {
            // Posiciones para luces (ventanas)
            private _posiciones = _x buildingPos -1;
            
            if (count _posiciones > 2) then {
                // Mezclamos las posiciones
                _posiciones = _posiciones call BIS_fnc_arrayShuffle;
                
                // Usamos 1-3 posiciones por edificio
                private _cantidadPos = (1 + floor(random 3)) min count _posiciones;
                _posiciones resize _cantidadPos;
                
                {
                    // Crear luz con bajo impacto
                    private _luz = "#lightpoint" createVehicleLocal _x;
                    _luz setLightBrightness (0.05 * _factorBrillo);
                    _luz setLightAmbient [0.8, 0.7, 0.5];
                    _luz setLightColor [0.9, 0.8, 0.6];
                    _luz setLightDayLight false;
                    
                    // Distancia corta para evitar impacto en rendimiento
                    _luz setLightUseFlare false;
                    _luz setLightAttenuation [4, 0, 0, 0.4, 30, 50];
                    
                    // Parpadeo aleatorio
                    [_luz, _factorBrillo] spawn {
                        params ["_luz", "_factorBrillo"];
                        while {!isNull _luz && CIUDAD_activo} do {
                            if (random 1 < 0.04) then { // 4% probabilidad
                                _luz setLightBrightness 0;
                                sleep (0.1 + random 0.2);
                                if (!isNull _luz && CIUDAD_activo) then {
                                    _luz setLightBrightness (0.05 * _factorBrillo);
                                };
                            };
                            sleep (10 + random 20);
                        };
                    };
                    
                    // Guardar referencia
                    CIUDAD_luces pushBack _luz;
                    _lucesCreadas = _lucesCreadas + 1;
                    
                    // Salir si alcanzamos el m√°ximo
                    if (_lucesCreadas >= _maxLuces) exitWith {};
                } forEach _posiciones;
            };
        };
        
        // Peque√±a pausa para evitar congelamiento
        if (_forEachIndex % 5 == 0) then {
            sleep 0.01;
        };
    } forEach _edificiosGrandes;
};

// =============================================
// üîä EFECTOS SONOROS URBANOS
// =============================================

// Funci√≥n para crear ambiente sonoro
CIUDAD_fnc_crearSonidos = {
    params ["_edificios", "_calles"];
    
    private _maxSonidos = CIUDAD_CONFIG select 3;
    
    // Verificar sonidos disponibles
    private _sonidosDisponibles = [];
    
    // Verificar sonidos de CIUDAD
    private _sonidosCiudad = [
        "A3\Sounds_F\environment\ambient\town\town1.wss",
        "A3\Sounds_F\environment\ambient\town\town2.wss",
        "A3\Sounds_F\environment\ambient\town\town3.wss"
    ];
    
    {
        if (fileExists _x) then {
            _sonidosDisponibles pushBack _x;
        };
    } forEach _sonidosCiudad;
    
    // Si no hay sonidos b√°sicos, a√±adir alternativas
    if (count _sonidosDisponibles == 0) then {
        private _sonidosAlternativos = [
            "A3\Sounds_F\sfx\blip1.wss",
            "A3\Sounds_F\environment\ambient\meadows\meadows_1.wss",
            "A3\Sounds_F\environment\ambient\meadows\meadows_2.wss"
        ];
        
        {
            if (fileExists _x) then {
                _sonidosDisponibles pushBack _x;
            };
        } forEach _sonidosAlternativos;
    };
    
    // Si no hay sonidos disponibles, salir
    if (count _sonidosDisponibles == 0) exitWith {};
    
    // Ubicaciones potenciales para sonidos
    private _ubicaciones = [];
    
    // Algunos sonidos en edificios
    if (count _edificios > 0) then {
        private _edificiosSeleccionados = _edificios call BIS_fnc_arrayShuffle;
        _edificiosSeleccionados resize ((_maxSonidos/2) min count _edificiosSeleccionados);
        
        {
            _ubicaciones pushBack [getPosATL _x, "edificio"];
        } forEach _edificiosSeleccionados;
    };
    
    // Algunos sonidos en calles
    if (count _calles > 0) then {
        private _callesSeleccionadas = _calles call BIS_fnc_arrayShuffle;
        _callesSeleccionadas resize ((_maxSonidos/2) min count _callesSeleccionadas);
        
        {
            _ubicaciones pushBack [getPosATL _x, "calle"];
        } forEach _callesSeleccionadas;
    };
    
    // Limitar cantidad total
    if (count _ubicaciones > _maxSonidos) then {
        _ubicaciones resize _maxSonidos;
    };
    
    // Crear triggers de sonido
    {
        _x params ["_pos", "_tipo"];
        
        // Crear trigger
        private _trg = createTrigger ["EmptyDetector", _pos, false];
        _trg setTriggerArea [80, 80, 0, false];
        _trg setTriggerActivation ["ANYPLAYER", "PRESENT", true];
        
        // Intervalo seg√∫n tipo
        private _intervalo = switch (_tipo) do {
            case "edificio": {45 + random 45};
            case "calle": {30 + random 30};
            default {40 + random 20};
        };
        
        _trg setTriggerInterval _intervalo;
        
        // Seleccionar sonido y volumen
        private _sonido = selectRandom _sonidosDisponibles;
        private _volumen = 0.3 + random 0.2;
        
        // Statement para reproducir sonido
        private _statement = format [
            "if (player distance [%2, %3, %4] < 80) then {playSound3D ['%1', objNull, false, [%2, %3, %4], %5, 1, 100];};", 
            _sonido, _pos select 0, _pos select 1, (_pos select 2) + 3, _volumen
        ];
        
        _trg setTriggerStatements ["this", _statement, ""];
        
        // Guardar referencia
        CIUDAD_sonidos pushBack _trg;
        
        // Peque√±a pausa
        if (_forEachIndex % 3 == 0) then {
            sleep 0.01;
        };
    } forEach _ubicaciones;
};

// =============================================
// üóëÔ∏è OBJETOS URBANOS Y DECORACI√ìN
// =============================================

// Funci√≥n para crear objetos urbanos
CIUDAD_fnc_crearObjetos = {
    params ["_calles"];
    
    private _maxObjetos = CIUDAD_CONFIG select 2;
    
    // Verificar que hay suficientes calles
    if (count _calles < 5) exitWith {};
    
    // Modelos de objetos urbanos comunes verificados
    private _modelosUrbanos = [];
    private _modelosCandidatos = [
        "Land_Garbage_square3_F",
        "Land_Garbage_line_F",
        "Land_BottlePlastic_V2_F",
        "Land_Can_V3_F",
        "Land_WoodenBox_F",
        "Land_MetalBarrel_F",
        "Land_BarrelEmpty_F",
        "Land_GarbageBin_01_F",
        "Land_Basket_F",
        "Land_CratesPlastic_F",
        "Land_CratesShabby_F",
        "Land_CratesWooden_F"
    ];
    
    {
        if (isClass(configFile >> "CfgVehicles" >> _x)) then {
            _modelosUrbanos pushBack _x;
        };
    } forEach _modelosCandidatos;
    
    // Si no hay modelos disponibles, salir
    if (count _modelosUrbanos == 0) exitWith {};
    
    // Mezclar calles aleatoriamente
    private _callesSeleccionadas = _calles call BIS_fnc_arrayShuffle;
    
    // Limitar cantidad de calles
    _callesSeleccionadas resize (_maxObjetos min count _callesSeleccionadas);
    
    // Crear objetos en lotes
    private _lote = [];
    private _contadorLote = 0;
    private _maxPorLote = 5;
    
    {
        // Obtener posici√≥n de la calle
        private _pos = getPosATL _x;
        private _dir = random 360;
        private _dist = 1.5 + random 2; // Al costado de la calle
        
        private _finalPos = [
            (_pos select 0) + (_dist * sin _dir),
            (_pos select 1) + (_dist * cos _dir),
            (_pos select 2)
        ];
        
        // Asegurarse que no est√° en la carretera
        if (!isOnRoad _finalPos) then {
            // Crear objeto
            private _modelo = selectRandom _modelosUrbanos;
            private _obj = createSimpleObject [_modelo, _finalPos];
            _obj setDir random 360;
            
            // Escala aleatoria para variedad
            _obj setObjectScale (0.7 + random 0.3);
            
            _lote pushBack _obj;
            _contadorLote = _contadorLote + 1;
            
            // Procesar en lotes
            if (_contadorLote >= _maxPorLote) then {
                CIUDAD_objetos append _lote;
                _lote = [];
                _contadorLote = 0;
                sleep 0.01;
            };
        };
    } forEach _callesSeleccionadas;
    
    // A√±adir √∫ltimo lote
    if (count _lote > 0) then {
        CIUDAD_objetos append _lote;
    };
};

// =============================================
// üçÇ BASURA PEQUE√ëA EN CALLES
// =============================================

// Funci√≥n para crear basura peque√±a
CIUDAD_fnc_crearBasuraPequena = {
    params ["_calles"];
    
    private _maxBasura = CIUDAD_CONFIG select 4;
    
    // Verificar que hay suficientes calles
    if (count _calles < 3) exitWith {};
    
    // Modelos de basura peque√±a verificados
    private _modelosBasura = [];
    
    // Lista de modelos de basura peque√±a disponibles en vanilla
    private _modelosCandidatos = [
        // Botellas y latas
        "Land_BottlePlastic_V1_F",
        "Land_BottlePlastic_V2_F",
        "Land_Can_V1_F",
        "Land_Can_V2_F",
        "Land_Can_V3_F",
        // Papeles y cartones
        "Land_Garbage_square3_F",
        "Land_Garbage_line_F",
        "Land_Ground_sheet_F",
        // Otros
        "Land_Money_F",
        "Land_TacticalBacon_F",
        "Land_DuctTape_F",
        "Land_FoodContainer_01_F",
        "Land_Tableware_01_cup_F",
        "Land_Tableware_01_stackOfplates_F"
    ];
    
    // Verificar modelos disponibles
    {
        if (isClass(configFile >> "CfgVehicles" >> _x)) then {
            _modelosBasura pushBack _x;
        };
    } forEach _modelosCandidatos;
    
    // Si no hay modelos disponibles, salir
    if (count _modelosBasura == 0) exitWith {};
    
    // Crear puntos aleatorios cerca de calles
    private _puntos = [];
    private _callesMezcladas = _calles call BIS_fnc_arrayShuffle;
    _callesMezcladas resize ((_maxBasura * 2) min count _callesMezcladas);
    
    {
        private _pos = getPosATL _x;
        
        // Crear 1-2 posiciones por calle seleccionada
        for "_i" from 1 to (1 + floor(random 2)) do {
            private _dir = random 360;
            private _dist = 0.5 + random 2.5;
            
            private _puntoPos = [
                (_pos select 0) + (_dist * sin _dir),
                (_pos select 1) + (_dist * cos _dir),
                (_pos select 2)
            ];
            
            // Comprobar que no est√° en la carretera
            if (!isOnRoad _puntoPos) then {
                _puntos pushBack _puntoPos;
            };
        };
    } forEach _callesMezcladas;
    
    // Limitar cantidad
    if (count _puntos > _maxBasura) then {
        _puntos resize _maxBasura;
    };
    
    // Crear objetos
    {
        private _modelo = selectRandom _modelosBasura;
        private _obj = createSimpleObject [_modelo, _x];
        
        // Rotaci√≥n aleatoria
        _obj setDir random 360;
        
        // Escala peque√±a para objetos de basura
        _obj setObjectScale (0.6 + random 0.4);
        
        CIUDAD_basuraPequena pushBack _obj;
        
        // Pausa cada 5 objetos
        if (_forEachIndex % 5 == 0) then {
            sleep 0.01;
        };
    } forEach _puntos;
};

// =============================================
// üèñÔ∏è OBJETOS DE PLAYA
// =============================================

// Funci√≥n para crear objetos de playa
CIUDAD_fnc_crearObjetosPlaya = {
    params ["_esPlaya"];
    
    // Salir si no estamos en playa
    if (!_esPlaya) exitWith {};
    
    private _maxObjetos = CIUDAD_CONFIG select 5;
    private _posJugador = getPosATL player;
    
    // Buscar puntos de playa
    private _puntosPlaya = [];
    private _radioPlaya = 150;
    
    for "_i" from 1 to 60 do {
        private _dir = random 360;
        private _dist = random _radioPlaya;
        
        private _checkPos = [
            (_posJugador select 0) + (_dist * sin _dir),
            (_posJugador select 1) + (_dist * cos _dir),
            0
        ];
        
        // Verificar si es playa
        private _superficie = surfaceType _checkPos;
        if (["sand", _superficie] call BIS_fnc_inString || 
            ["beach", _superficie] call BIS_fnc_inString || 
            ["coast", _superficie] call BIS_fnc_inString) then {
            
            // Ajustar altura al terreno
            _checkPos set [2, getTerrainHeightASL _checkPos];
            
            // Verificar que no est√° bajo el agua
            if (!surfaceIsWater _checkPos) then {
                _puntosPlaya pushBack _checkPos;
            };
        };
    };
    
    // Verificar si se encontraron puntos de playa
    if (count _puntosPlaya == 0) exitWith {};
    
    // Limitar cantidad
    if (count _puntosPlaya > _maxObjetos) then {
        _puntosPlaya resize _maxObjetos;
    };
    
    // Objetos de playa disponibles en vanilla
    private _modelosPlaya = [];
    private _modelosCandidatos = [
        // Toallas, sombrillas, cubos
        "Land_Sunshade_F",
        "Land_Sunshade_01_F",
        "Land_Sunshade_02_F",
        "Land_Sunshade_03_F",
        "Land_Sunshade_04_F",
        "Land_Ground_sheet_blue_F",
        "Land_Ground_sheet_yellow_F",
        "Land_Ground_sheet_folded_blue_F",
        "Land_Ground_sheet_folded_yellow_F",
        // Objetos de playa
        "Land_Bucket_F",
        "Land_Bucket_clean_F",
        "Land_Bucket_painted_F",
        "Land_PlasticCase_01_small_F",
        "Land_PlasticCase_01_small_gray_F",
        // Pelotas y juguetes
        "Land_Football_01_F",
        "Land_BaseballBat_01_F"
    ];
    
    // Verificar modelos disponibles
    {
        if (isClass(configFile >> "CfgVehicles" >> _x)) then {
            _modelosPlaya pushBack _x;
        };
    } forEach _modelosCandidatos;
    
    // Si no hay modelos disponibles, usar alternativas
    if (count _modelosPlaya == 0) then {
        private _modelosAlternativa = [
            "Land_Basket_F",
            "Land_Can_V3_F",
            "Land_BottlePlastic_V2_F"
        ];
        
        {
            if (isClass(configFile >> "CfgVehicles" >> _x)) then {
                _modelosPlaya pushBack _x;
            };
        } forEach _modelosAlternativa;
    };
    
    // Si a√∫n no hay modelos, salir
    if (count _modelosPlaya == 0) exitWith {};
    
    // Crear objetos
    {
        private _modelo = selectRandom _modelosPlaya;
        private _obj = createSimpleObject [_modelo, _x];
        
        // Rotaci√≥n aleatoria
        _obj setDir random 360;
        
        // Escala aleatoria seg√∫n tipo
        if (_modelo in ["Land_Sunshade_F", "Land_Sunshade_01_F", "Land_Sunshade_02_F", 
                         "Land_Sunshade_03_F", "Land_Sunshade_04_F"]) then {
            _obj setObjectScale (0.8 + random 0.2);
        } else {
            _obj setObjectScale (0.6 + random 0.4);
        };
        
        CIUDAD_objetosPlaya pushBack _obj;
        
        // Pausa cada 5 objetos
        if (_forEachIndex % 5 == 0) then {
            sleep 0.01;
        };
    } forEach _puntosPlaya;
};

// =============================================
// üå∏ FLORES Y PLANTAS DECORATIVAS - CORREGIDO
// =============================================

// Funci√≥n para crear flores y plantas
CIUDAD_fnc_crearFlores = {
    params ["_calles"];
    
    private _maxFlores = CIUDAD_CONFIG select 6;
    
    // Verificar que hay suficientes calles
    if (count _calles < 5) exitWith {};
    
    // Modelos de flores y plantas
    private _modelosFlores = [];
    private _modelosCandidatos = [
        // Plantas y flores
        "Land_FlowerPot_01_F",
        "Land_FlowerPot_01_Flower_F",
        "Land_Flower_01_F",
        "Land_Flower_02_F",
        "Land_Bush_01_F",
        // Plantas decorativas
        "Land_TreeBin_F",
        "Land_Hedge_01_s_2m_F",
        "Land_Hedge_01_s_4m_F",
        "Land_FlowerPot_01_Dirt_F",
        "Land_FlowerPot_01_Flower_F",
        "Land_FlowerPot_01_Decorated_F",
        // Alternativas
        "A3\plants_f\Bush\b_FicusC1s_F.p3d",
        "A3\plants_f\Bush\b_NeriumO2s_F.p3d",
        "A3\plants_f\Bush\b_NeriumO2s_white_F.p3d",
        "A3\plants_f\Bush\b_ArundoD3s_F.p3d"
    ];
    
    // Verificar modelos disponibles - primero objetos completos
    {
        if (_forEachIndex < 10) then { // Solo verificar los primeros 10 (objetos completos)
            if (isClass(configFile >> "CfgVehicles" >> _x)) then {
                _modelosFlores pushBack _x;
            };
        };
    } forEach _modelosCandidatos;
    
    // Si no hay suficientes, a√±adir modelos simples
    if (count _modelosFlores < 3) then {
        {
            if (_forEachIndex >= 10) then { // Verificar los √∫ltimos (modelos simples)
                if (fileExists _x) then {
                    _modelosFlores pushBack _x;
                };
            };
        } forEach _modelosCandidatos;
    };
    
    // Si no hay modelos disponibles, salir
    if (count _modelosFlores == 0) exitWith {};
    
    // Buscar puntos para flores (cerca de aceras)
    private _puntosFlores = [];
    private _callesMezcladas = _calles call BIS_fnc_arrayShuffle;
    
    {
        private _pos = getPosATL _x;
        private _dir = random 360;
        private _dist = 1.8 + random 1.5; // M√°s alejado del centro
        
        private _puntoPos = [
            (_pos select 0) + (_dist * sin _dir),
            (_pos select 1) + (_dist * cos _dir),
            (_pos select 2)
        ];
        
        // Solo si no est√° en carretera
        if (!isOnRoad _puntoPos) then {
            _puntosFlores pushBack _puntoPos;
        };
        
        // Limitar b√∫squeda
        if (count _puntosFlores >= _maxFlores * 2) exitWith {};
    } forEach _callesMezcladas;
    
    // Mezclar puntos y limitar cantidad
    _puntosFlores = _puntosFlores call BIS_fnc_arrayShuffle;
    _puntosFlores resize (_maxFlores min count _puntosFlores);
    
    // Crear objetos - VERSI√ìN SIMPLIFICADA Y CORREGIDA
    {
        private _modelo = selectRandom _modelosFlores;
        private _obj = createSimpleObject [_modelo, _x];
        
        // Rotaci√≥n aleatoria
        _obj setDir random 360;
        
        // Determinar escala basada en nombre - SIMPLIFICADO
        private _escala = 0.8;
        private _nombreLower = toLower _modelo;
        
        switch (true) do {
            case ([".p3d", _nombreLower] call BIS_fnc_inString): { _escala = 0.4 + random 0.3 };
            case (["hedge", _nombreLower] call BIS_fnc_inString): { _escala = 0.5 + random 0.3 };
            case (["tree", _nombreLower] call BIS_fnc_inString): { _escala = 0.7 + random 0.2 };
            default { _escala = 0.9 + random 0.2 };
        };
        
        _obj setObjectScale _escala;
        CIUDAD_flores pushBack _obj;
        
        // Pausa cada 3 objetos
        if (_forEachIndex % 3 == 0) then {
            sleep 0.01;
        };
    } forEach _puntosFlores;
};
// =============================================
// üßπ FUNCIONES DE LIMPIEZA
// =============================================

// Funci√≥n para limpiar todos los efectos
CIUDAD_fnc_limpiarTodo = {
    // Limpiar luces
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_luces;
    CIUDAD_luces = [];
    
    // Limpiar sonidos
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_sonidos;
    CIUDAD_sonidos = [];
    
    // Limpiar objetos
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_objetos;
    CIUDAD_objetos = [];
    
    // Limpiar basura peque√±a
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_basuraPequena;
    CIUDAD_basuraPequena = [];
    
    // Limpiar objetos de playa
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_objetosPlaya;
    CIUDAD_objetosPlaya = [];
    
    // Limpiar flores
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_flores;
    CIUDAD_flores = [];
    
    // Limpiar triggers
    {
        if (!isNull _x) then {
            deleteVehicle _x;
        };
    } forEach CIUDAD_triggers;
    CIUDAD_triggers = [];
    
    // Restablecer estado
    CIUDAD_activo = false;
};

// =============================================
// üöÄ INICIALIZACI√ìN Y CONTROL PRINCIPAL
// =============================================

// Funci√≥n para inicializar sistema
CIUDAD_fnc_inicializar = {
    if (CIUDAD_initialized) exitWith {};
    
    // Comprobar peri√≥dicamente si estamos en ciudad
    [] spawn {
        while {true} do {
            private _resultado = call CIUDAD_fnc_detectarCiudad;
            _resultado params ["_esCiudad", "_esPlaya", "_edificios", "_calles"];
            
            if (_esCiudad && !CIUDAD_activo) then {
                // Activar ciudad
                CIUDAD_activo = true;
                
                // Crear elementos
                [_edificios] call CIUDAD_fnc_crearLuces;
                [_edificios, _calles] call CIUDAD_fnc_crearSonidos;
                [_calles] call CIUDAD_fnc_crearObjetos;
                [_calles] call CIUDAD_fnc_crearBasuraPequena;
                [_calles] call CIUDAD_fnc_crearFlores;
                [_esPlaya] call CIUDAD_fnc_crearObjetosPlaya;
            };
            
            if (!_esCiudad && CIUDAD_activo) then {
                // Desactivar ciudad
                call CIUDAD_fnc_limpiarTodo;
            };
            
            // Comprobaci√≥n cada 30 segundos
            sleep 30;
        };
    };
    
    CIUDAD_initialized = true;
};

// Inicializaci√≥n autom√°tica con retraso para evitar conflictos
[] spawn {
    sleep 10; // Esperar 10 segundos para carga completa
    call CIUDAD_fnc_inicializar;
};
