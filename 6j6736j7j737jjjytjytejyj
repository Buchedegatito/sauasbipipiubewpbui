BloodLust_BleedSplatters = [];

BloodLust_MakeUnitBleed =
{
    _hitSelection      = _this select 0;
    _duration          = _this select 1;
    _target            = _hitSelection select 0;
    _shooter           = _hitSelection select 1;
    _bullet            = _hitSelection select 2;
    _hitPosition       = _hitSelection select 3;
    _velocity          = _hitSelection select 4;
    _selections        = _hitSelection select 5;
    _ammo              = _hitSelection select 6;
    _direction         = _hitSelection select 7;
    _radius            = _hitSelection select 8;
    _surface           = _hitSelection select 9;
    _isDirectHit       = _hitSelection select 10;
    _bulletVectorDir = vectorDir _bullet;
    _bulletVectorUp = vectorUp _bullet;

    _selectionName = selectRandom (_selections select { _x select [0, 3] != "Hit" });
    if (isNil "_selectionName") exitWith {};

    _endTime           = time + _duration;
    _arterialBloodSprayEndTime = time + BloodLust_ArterialBloodSprayDuration;
    _initialUnitDamage = damage _target;
    _bleedSmearEndTime = time + BloodLust_BleedSmearDuration;
    _target setVariable [format ["BloodLust_NextBleedTime_%1", _selectionName], [0] call BloodLust_GetNextBleedTime];
    _target setVariable [format ["BloodLust_NextSmearTime_%1", _selectionName], [0] call BloodLust_GetNextSmearTime];

    [
        BloodLust_BleedingFrameHandler,
        0,
        [
            _target,
            _initialUnitDamage,
            _velocity,
            _selectionName,
            _bulletVectorDir,
            _bulletVectorUp,
            _endTime,
            _arterialBloodSprayEndTime,
            _bleedSmearEndTime
        ]
    ] call CBA_fnc_addPerFrameHandler;
};

BloodLust_BleedingFrameHandler =
{
    _args = _this select 0;
    _target = _args select 0;
    _initialUnitDamage = _args select 1;
    _projectileVelocity = _args select 2;
    _selectionName = _args select 3;
    _bulletVectorDir = _args select 4;
    _bulletVectorUp = _args select 5;
    _endTime = _args select 6;
    _arterialBloodSprayEndTime = _args select 7;
    _bleedSmearEndTime = _args select 8;
    _nextBleedTime = _target getVariable [format ["BloodLust_NextBleedTime_%1", _selectionName], 0];
    _nextSmearTime = _target getVariable [format ["BloodLust_NextSmearTime_%1", _selectionName], 0];
    _splatterAngle = random 360;
    _bleedProgress = 1 - ((_endTime - time) / _endTime);
    _smearProgress = 1 - ((_bleedSmearEndTime - time) / _bleedSmearEndTime);
    _isBleedingFinished = 
        (BloodLust_IsBleedingTiedToUnitState && !isBleeding _target) || 
        (!BloodLust_IsBleedingTiedToUnitState && (time >= _endTime || (damage _target < _initialUnitDamage))) ||
        (_target getVariable ["BloodLust_IsVaporized", false]);

    if(_isBleedingFinished) exitWith
    {
        {
            [_target] call _x;
        } foreach BloodLust_OnUnitBleedPostEventHandlers;
        [_this select 1] call CBA_fnc_removePerFrameHandler;
    };

    if (!BloodLust_IsSplatteringEnabledForUnitsInVehicles && vehicle _target != _target) exitWith {}; // unit is in vehicle

    _selectionPosition = _target selectionPosition [_selectionName, "HitPoints"];
    _hitPointPosition = AGLToASL(_target modelToWorld _selectionPosition);
    _projectileDirection = vectorNormalized _projectileVelocity;
    _intersectionEndPosition = AGLToASL((_target modelToWorld _selectionPosition) vectorAdd (_projectileDirection vectorMultiply 0.3));
    _surfaceIntersections = lineIntersectsSurfaces
    [
        _hitPointPosition,
        _intersectionEndPosition,
        _target,
        vehicle _target,
        true,
        10,
        "VIEW",
        "NONE"
    ] select {
        _intersectingObject  = _x select 2;
        _isObjectInIntersectionBlackList = [typeOf _intersectingObject, (getModelInfo _intersectingObject) select 0] call BloodLust_IsClassInIntersectionBlackList;
        !_isObjectInIntersectionBlackList;
    };

    {
        [
            _target,
            _initialUnitDamage,
            _projectileVelocity,
            _selectionName,
            _bulletVectorDir,
            _bulletVectorUp,
            _endTime,
            _arterialBloodSprayEndTime,
            _nextBleedTime,
            _hitPointPosition,
            _intersectionEndPosition,
            _surfaceIntersections
        ] call _x;
    } foreach BloodLust_OnUnitBleedPreEventHandlers;

    if(count _surfaceIntersections == 0) then
    {
        _intersectionEndPosition = AGLToASL(_target modelToWorld ((_target selectionPosition [_selectionName, "HitPoints"]) vectorAdd [0, 0, -0.15]));
        _surfaceIntersections = lineIntersectsSurfaces
        [
            _hitPointPosition,
            _intersectionEndPosition,
            _target,
            vehicle _target,
            true,
            10,
            "VIEW",
            "NONE"
        ] select {
            _intersectingObject  = _x select 2;
            _isObjectInIntersectionBlackList = [typeOf _intersectingObject, (getModelInfo _intersectingObject) select 0] call BloodLust_IsClassInIntersectionBlackList;
            _return = !_isObjectInIntersectionBlackList;
            _return;
        };
    };

    if(count _surfaceIntersections > 0 && time <= _bleedSmearEndTime) then // Perform bleed smearing.
    {
        if (time >= _nextSmearTime) then
        {
            _previousSmearPosition = _target getVariable [format ["BloodLust_PreviousBleedSmearPosition_%1", _selectionName], [0, 0, 0]];
            _surfaceIntersection = _surfaceIntersections select 0;
            _surfacePosition = _surfaceIntersection select 0;
            _surfaceNormal = _surfaceIntersection select 1;
            _splatterPosition = _surfacePosition vectorAdd (_surfaceNormal vectorMultiply 0.01);

            if(_splatterPosition distance _previousSmearPosition >= BloodLust_BleedSmearSpacing) then
            {
                _splatterAngle = ([_splatterPosition, _previousSmearPosition] call BIS_fnc_dirTo) + 90;
                _splatter = call BloodLust_CreateBloodSmearObject;
                _splatter setObjectTexture [0, selectRandom BloodLust_SmearTextures];
                _splatter setPosASL _splatterPosition;
                [_splatter, _surfaceNormal, _splatterAngle] call BloodLust_RotateObjectAroundNormal;

                {
                    [_splatter] call _x;
                } foreach BloodLust_OnSmearSplatterCreatedEventHandlers;

                _target setVariable [format ["BloodLust_PreviousBleedSmearPosition_%1", _selectionName], _splatterPosition];
                _target setVariable [format ["BloodLust_NextBleedTime_%1", _selectionName], [_bleedProgress] call BloodLust_GetNextBleedTime];
                _target setVariable [format ["BloodLust_NextSmearTime_%1", _selectionName], [_smearProgress] call BloodLust_GetNextSmearTime];
            };
        };
    }
    else // Perform bleed droplet or blood pooling.
    {
        if (time >= _nextBleedTime) then
        {
            _jitter =
            [
                BloodLust_BleedSplatterJitterAmount - (random (BloodLust_BleedSplatterJitterAmount * 2)),
                BloodLust_BleedSplatterJitterAmount - (random (BloodLust_BleedSplatterJitterAmount * 2)),
                BloodLust_BleedSplatterJitterAmount - (random (BloodLust_BleedSplatterJitterAmount * 2))
            ];
            _splatterPosition    = (AGLtoASL(_target modelToWorldVisual (_target selectionPosition [_selectionName, "HitPoints"]))) vectorAdd _jitter;
            _surfaceIntersection = [_splatterPosition, _target, vehicle _target] call BloodLust_GetSurfaceIntersection;
            _surfaceDistance     = _surfaceIntersection select 0;
            _surfaceNormal       = _surfaceIntersection select 1;
            _surfacePosition     = _surfaceIntersection select 2;

            if(_surfaceDistance > 0.3) then // Perform bleed droplet because blood is dropping far enough from surface / bleeding is not in contact with a surface.
            {
                _splatterPosition = _surfacePosition vectorAdd (_surfaceNormal vectorMultiply 0.01);
                _splatter = call BloodLust_CreateTinyBleedSplatterObject;
                _splatter setObjectTexture [0, selectRandom BloodLust_BleedTextures];
                _splatter setPosASL _splatterPosition;
                [_splatter, _surfaceNormal, _splatterAngle] call BloodLust_RotateObjectAroundNormal;

                {
                    [_splatter] call _x;
                } foreach BloodLust_OnBleedSplatterCreatedEventHandlers;

                [selectRandom BloodLust_BleedSounds, _splatter, false, _splatterPosition, _surfaceDistance / (BloodLust_BleedSoundAudibleVolume max 1), 1, BloodLust_BleedSoundAudibleDistance] call BloodLust_PlaySound;
                _target setVariable [format ["BloodLust_NextBleedTime_%1", _selectionName], [_bleedProgress] call BloodLust_GetNextBleedTime];
                _target setVariable [format ["BloodLust_NextSmearTime_%1", _selectionName], [_smearProgress] call BloodLust_GetNextSmearTime];

                if(BloodLust_IsArterialBloodSprayEnabled && time <= _arterialBloodSprayEndTime && random 1 <= BloodLust_ArterialBloodSprayProbability) then
                {
                    _arterialBloodSprayPosition = _hitPointPosition;
                    _arterialBloodSprayDirection = vectorNormalized (((_bulletVectorDir vectorAdd _jitter)) vectorCrossProduct (vectorDir _target));
                    _arterialBloodSprayUp = vectorNormalized (((_bulletVectorUp vectorAdd _jitter)) vectorCrossProduct (vectorUp _target));
                    [
                        _arterialBloodSprayPosition,
                        _arterialBloodSprayDirection,
                        _arterialBloodSprayUp
                    ] call BloodLust_CreateArterialBloodSpray;
                };
            }
            else // Perform blood pool because bleeding is occurring in contact with surface.
            {
                if(BloodLust_IsBloodPoolingEnabled) then 
                {
                    _hasBloodPool = _target getVariable ["BloodLust_HasBloodPool", false];
                    _unitSpeed = _target call BloodLust_GetVelocityMagnitude;
                    if(!_hasBloodPool && !alive _target && _unitSpeed < 1) then
                    {
                        _target setVariable ["BloodLust_HasBloodPool", true];
                        _bloodPool = call BloodLust_CreateBloodPoolObject;
                        _bloodPool setPosASL (_surfacePosition vectorAdd (_surfaceNormal vectorMultiply 0.01));
                        [_bloodPool, _surfaceNormal, _splatterAngle] call BloodLust_RotateObjectAroundNormal;
                    };
                };
            };
        };
    };
};

BloodLust_AttachBleeding =
{
    _object   = _this select 0;
    _duration = _this select 1;
    _minimumSpeed = _this select 2;
    _endTime = time + _duration;

    [{
        _args = _this select 0;
        _object = _args select 0;
        _endTime = _args select 1;
        _minimumSpeed = _args select 2;
        _previousBleedTime = _object getVariable ["BloodLust_PreviousBleedTime", -1];

        if (time >= _endTime) then
        {
            [_this select 1] call CBA_fnc_removePerFrameHandler;
        }
        else
        {
            if(time > _previousBleedTime) then
            {
                _surfaceIntersection = [getPosASL _object, _object, vehicle _object] call BloodLust_GetSurfaceIntersection;
                _surfaceDistance     = _surfaceIntersection select 0;
                _surfaceNormal       = _surfaceIntersection select 1;
                _surfacePosition    = _surfaceIntersection select 2;
                _surfaceIsIntersecting = _surfaceIntersection select 3;

                if(_surfaceIsIntersecting && _surfaceDistance <= 0.05 && _object call BloodLust_GetVelocityMagnitude >= _minimumSpeed) then
                {
                    _splatterPosition = _surfacePosition vectorAdd (_surfaceNormal vectorMultiply 0.01);
                    _splatter = call BloodLust_CreateBleedSplatterObject;
                    _splatter setDir (random 360);
                    _splatter setObjectTexture [0, selectRandom BloodLust_BleedTextures];
                    _splatter setPosASL _splatterPosition;
                    _splatter setVectorUp _surfaceNormal;
                    _object setVariable ["BloodLust_PreviousBleedTime", time];

                    {
                        [_splatter] call _x;
                    } foreach BloodLust_OnBleedSplatterCreatedEventHandlers;
                };
            };
        };
    }, 0, [_object, _endTime, _minimumSpeed]] call CBA_fnc_addPerFrameHandler;
};

BloodLust_GetNextBleedTime =
{
    params ["_bleedProgress"];
    (
        time +
        (BloodLust_BleedFrequency + (random BloodLust_BleedFrequencyVariance)) +
        (_bleedProgress * BloodLust_BleedFrequencySlowdownAmount)
    );
};

BloodLust_GetNextSmearTime =
{
    params ["_smearProgress"];
    (
        time +
        (BloodLust_BleedFrequency + (random BloodLust_BleedFrequencyVariance)) +
        (_smearProgress * BloodLust_BleedSmearFrequencySlowdownAmount)
    );
};

BloodLust_AttachSmearBleeding =
{
    _object   = _this select 0;
    _duration = _this select 1;
    _minimumSpeed = _this select 2;
    _endTime = time + _duration;

    [{
        _args = _this select 0;
        _object = _args select 0;
        _endTime = _args select 1;
        _minimumSpeed = _args select 2;
        _previousBleedTime = _object getVariable ["BloodLust_PreviousBleedTime", -1];

        if (time >= _endTime) then
        {
            [_this select 1] call CBA_fnc_removePerFrameHandler;
        }
        else
        {
            if(time > _previousBleedTime) then
            {
                _surfaceIntersection = [getPosASL _object, _object, vehicle _object] call BloodLust_GetSurfaceIntersection;
                _surfaceDistance     = _surfaceIntersection select 0;
                _surfaceNormal       = _surfaceIntersection select 1;
                _surfacePosition    = _surfaceIntersection select 2;
                _surfaceIsIntersecting = _surfaceIntersection select 3;

                if(_surfaceIsIntersecting && _surfaceDistance <= 0.05 && _object call BloodLust_GetVelocityMagnitude >= _minimumSpeed) then
                {
                    _splatterPosition = _surfacePosition vectorAdd (_surfaceNormal vectorMultiply 0.01);
                    _splatter = call BloodLust_CreateBleedSplatterObject;
                    _splatter setDir (random 360);
                    _splatter setObjectTexture [0, selectRandom BloodLust_SmearTextures];
                    _splatter setPosASL _splatterPosition;
                    _splatter setVectorUp _surfaceNormal;
                    _object setVariable ["BloodLust_PreviousBleedTime", time];

                    {
                        [_splatter] call _x;
                    } foreach BloodLust_OnBleedSplatterCreatedEventHandlers;
                };
            };
        };
    }, 0, [_object, _endTime, _minimumSpeed]] call CBA_fnc_addPerFrameHandler;
};

BloodLust_CreateBloodSmearObject =
{
    if(call BloodLust_IsMaxBleedSplattersReached) then
    {
        call BloodLust_RemoveOldBleedSplatter;
    };

    _smear = objNull;
    if(isMultiplayer) then
    {
        _smear = "BloodSplatter_SmallPlane" createVehicleLocal [0, 0, 0];
    }
    else
    {
        _smear = createSimpleObject ["BloodSplatter_SmallPlane", [0, 0, 0]];
    };

    BloodLust_BleedSplatters pushBack _smear;
    _smear;
};

BloodLust_CreateBleedSplatterObject =
{
    if(call BloodLust_IsMaxBleedSplattersReached) then
    {
        call BloodLust_RemoveOldBleedSplatter;
    };

    _splatter = objNull;
    if(isMultiplayer) then
    {
        _splatter = "BloodSplatter_SmallPlane" createVehicleLocal [0, 0, 0];
    }
    else
    {
        _splatter = createSimpleObject ["BloodSplatter_SmallPlane", [0, 0, 0]];
    };

    BloodLust_BleedSplatters pushBack _splatter;
    _splatter;
};

BloodLust_CreateTinyBleedSplatterObject =
{
    if(call BloodLust_IsMaxBleedSplattersReached) then
    {
        call BloodLust_RemoveOldBleedSplatter;
    };

    _splatter = objNull;
    if(isMultiplayer) then
    {
        _splatter = "BloodSplatter_TinyPlane" createVehicleLocal [0, 0, 0];
    }
    else
    {
        _splatter = createSimpleObject ["BloodSplatter_TinyPlane", [0, 0, 0]];
    };

    BloodLust_BleedSplatters pushBack _splatter;
    _splatter;
};

BloodLust_IsMaxBleedSplattersReached =
{
    _return = false;
    if(count BloodLust_BleedSplatters >= BloodLust_MaxBleedSplatters) then
    {
        _return = true;
    };
    _return;
};

BloodLust_RemoveOldBleedSplatter =
{
    if(count BloodLust_BleedSplatters > 0) then
    {
        _splatter = BloodLust_BleedSplatters select 0;
        BloodLust_BleedSplatters deleteAt 0;
        deleteVehicle _splatter;
    };
};

//Blood Lust -- Blood splatter mod.
//Copyright (C) 2016  Gavin N. Alvesteffer

_HighDamageVaporization =
{
	_selection = _this select 0;
	_target = _selection select 0;
	_ammo = _selection select 6;
	_hitValue = _ammo select 0;

	if(_hitValue >= 50) then
	{
		[_unit, _damage] call BloodLust_VaporizeUnit;
	};
};

BloodLust_OnUnitHitPartPostEventHandlers pushBack _HighDamageVaporization;


//Original Author: BadBenson.
//Modified by Gavin N. Alvesteffer with permission from BadBenson.
//Copyright (C) 2016  BadBenson & Gavin N. Alvesteffer

//Usage: _unit call BloodLust_GoreMist;
BloodLust_GoreMistEffect =
{
    _source = "#particlesource" createVehicleLocal [0, 0, 0];
    _source setPosASL (getPosASL _this);
    _source setParticleParams
    [
        ["\a3\data_f\particleEffects\universal\universal.p3d",16,8,48,0],"",
        "billboard",
        0,
        0.5,
        [0,0,0.5],
        [0,0,2],
        0,10.30,1,-0.1,
        [0,6],
        [[0.5,0,0,0.8],[0.3,0,0,0.8],[0.25,0,0,0.5],[0.15,0,0,0]],
        [0.01],
        0.01,
        0.08,
        "",
        "",
        _this,
        0,
        true,
        0.5,
        [[0.5,0,0,1]]
    ];
     _source setDropInterval 1;
     _endTime = time + 1;
    [{
        _args = _this select 0;
        _source = _args select 0;
        _endTime = _args select 1;
        if(time >= _endTime) then
        {
            deleteVehicle _source;
            [_this select 1] call CBA_fnc_removePerFrameHandler;
        };
    }, 0, [_source, _endTime]] call CBA_fnc_addPerFrameHandler;
};


BloodLust_Gibs = [];

BloodLust_CreateGibObject =
{
    _classname = _this;
    if(call BloodLust_IsMaxGibsReached) then
    {
        call BloodLust_RemoveOldGib;
    };
    _gib = _classname createVehicleLocal [0,0,0];
    BloodLust_Gibs pushBack _gib;
    _gib;
};

BloodLust_IsMaxGibsReached =
{
    _return = false;
    if(count BloodLust_Gibs >= BloodLust_MaxGibs) then
    {
        _return = true;
    };
    _return;
};

BloodLust_RemoveOldGib =
{
    if(count BloodLust_Gibs > 0) then
    {
        _gib = BloodLust_Gibs select 0;
        deleteVehicle _gib;
        BloodLust_Gibs deleteAt 0;
    };
};


BloodLust_StartBloodTrail =
{
    params
    [
        "_unit",
        "_selection",
        "_duration"
    ];

    if (!isNil { _unit getVariable "BloodLust_PreviousBloodTrailPosition" }) exitWith {}; // blood trail already exists for unit + selection.
    _unit setVariable [format ["BloodLust_PreviousBloodTrailSelectionPosition-%1", _selection], [_unit, _selection] call BloodLust_GetSelectionWorldPositionASL];

    [
        {
            _args = _this select 0;
            _handle = _this select 1;
            _unit = _args select 0;
            _selection = _args select 1;
            _startTime = _args select 2;
            _duration = _args select 3;
            _previousSelectionPosition = _unit getVariable format ["BloodLust_PreviousBloodTrailSelectionPosition-%1", _selection];
            _currentSelectionPosition = [_unit, _selection] call BloodLust_GetSelectionWorldPositionASL;
            _trailLength = _currentSelectionPosition distance _previousSelectionPosition;
            _endTime = _startTime + _duration;

            if (time >= _endTime || _trailLength >= BloodLust_BloodTrailCancelDistance) exitWith
            {
                [_handle] call CBA_fnc_removePerFrameHandler;
            };

            if (alive _unit) exitWith {}; // Wait until unit is dead.

            // Create blood trails between previous and current selection position
            _previousPosition = _previousSelectionPosition;
            _iterations = floor (_trailLength / BloodLust_BloodTrailSpacing);
            if (_iterations > 0) then
            {
                for "_iteration" from 0 to _iterations do
                {
                    _currentPosition = [_previousSelectionPosition, _currentSelectionPosition, _iteration / _iterations] call BIS_fnc_lerpVector;
                    if (!(_currentPosition isEqualTo _previousPosition)) then
                    {
                        _splatterAngle = ([_currentPosition, _previousPosition] call BIS_fnc_dirTo) + 90;
                        _splatter =
                        [
                            _unit,
                            _currentPosition,
                            [0, 0, -1],
                            BloodLust_BloodSplatterIntersectionMaxDistance,
                            _splatterAngle,
                            selectRandom BloodLust_BloodTrailTextures,
                            call BloodLust_CreateBleedSplatterObject
                        ] call BloodLust_CreateBloodSplatter;
                        _previousPosition = _currentPosition;
                    };
                };
            };

            _unit setVariable [format ["BloodLust_PreviousBloodTrailSelectionPosition-%1", _selection], _currentSelectionPosition];
        },
        0.1,
        [
            _unit,
            _selection,
            time,
            _duration
        ]
    ] call CBA_fnc_addPerFrameHandler;
};


BloodLust_ArterialBloodSprays = [];
BloodLust_BloodSprays = [];

BloodLust_CreateArterialBloodSpray =
{
    _positionASL = _this select 0;
    _vectorDir = _this select 1;
    _vectorUp = _this select 2;
    if(call BloodLust_IsMaxArterialBloodSpraysReached) exitWith {};

    _spray = objNull;
    if(isMultiplayer) then
    {
        _spray = "BloodSplatter_SmallSprayPlane" createVehicleLocal [0, 0, 0];
    }
    else
    {
        _spray = createSimpleObject ["BloodSplatter_SmallSprayPlane", [0, 0, 0]];
    };

    BloodLust_ArterialBloodSprays pushBack _spray;
    _spray setPosASL _positionASL;
    _spray setVectorDirAndUp [_vectorDir, _vectorUp];
    _spray setPosASL (AGLToASL(_spray modelToWorld [0, 0.3, 0]));
    [selectRandom BloodLust_SprayTextures, BloodLust_ArterialBloodSprayFramerate, false, true, _spray, BloodLust_OnArterialBloodSprayAnimationEnd] call BloodLust_AnimateObjectTexture;
    if(BloodLust_IsBloodSpraySoundEnabled) then
    {
        [selectRandom BloodLust_BloodSpraySounds, _spray, false, getPosASL _spray, BloodLust_BloodSpraySoundAudibleVolume, 1.2 - (random 0.4), BloodLust_BloodSpraySoundAudibleDistance * 0.5] call BloodLust_PlaySound;
    };

    _spray;
};

BloodLust_CreateBloodSpray =
{
    _positionASL = _this select 0;
    _vectorDir = _this select 1;
    _vectorUp = _this select 2;
    if(isNil "_positionASL" || isNil "_vectorDir" || isNil "_vectorUp") exitWith {};
    if(call BloodLust_IsMaxBloodSpraysReached) exitWith {};

    _spray = objNull;
    if(isMultiplayer) then
    {
        _spray = "BloodSplatter_SprayPlane" createVehicleLocal [0, 0, 0];
    }
    else
    {
        _spray = createSimpleObject ["BloodSplatter_SprayPlane", [0, 0, 0]];
    };

    BloodLust_BloodSprays pushBack _spray;
    _spray setPosASL _positionASL;
    _spray setVectorDirAndUp [_vectorDir, _vectorUp];
    _spray setPosASL (AGLToASL(_spray modelToWorld [0, 0.9, 0]));
    [selectRandom BloodLust_SprayTextures, BloodLust_BloodSprayFramerate, false, true, _spray, BloodLust_OnBloodSprayAnimationEnd] call BloodLust_AnimateObjectTexture;
    if(BloodLust_IsBloodSpraySoundEnabled) then
    {
        [selectRandom BloodLust_BloodSpraySounds, _spray, false, getPosASL _spray, BloodLust_BloodSpraySoundAudibleVolume, 1.2 - (random 0.4), BloodLust_BloodSpraySoundAudibleDistance] call BloodLust_PlaySound;
    };

    _spray;
};

BloodLust_OnBloodSprayAnimationEnd =
{
    _bloodSprayObject = param [0];
    BloodLust_BloodSprays = BloodLust_BloodSprays - [_bloodSprayObject];
};

BloodLust_OnArterialBloodSprayAnimationEnd =
{
    _bloodSprayObject = param [0];
    BloodLust_ArterialBloodSprays = BloodLust_ArterialBloodSprays - [_bloodSprayObject];
};

BloodLust_IsMaxArterialBloodSpraysReached =
{
    _return = false;
    if(count BloodLust_ArterialBloodSprays >= BloodLust_MaxArterialBloodSprays) then
    {
        _return = true;
    };
    _return;
};

BloodLust_RemoveOldArterialBloodSpray =
{
    if(count BloodLust_ArterialBloodSprays > 0) then
    {
        _spray = BloodLust_ArterialBloodSprays select 0;
        deleteVehicle _spray;
        BloodLust_ArterialBloodSprays deleteAt 0;
    };
};

BloodLust_IsMaxBloodSpraysReached =
{
    _return = false;
    if(count BloodLust_BloodSprays >= BloodLust_MaxBloodSprays) then
    {
        _return = true;
    };
    _return;
};

BloodLust_RemoveOldBloodSpray =
{
    if(count BloodLust_BloodSprays > 0) then
    {
        _spray = BloodLust_BloodSprays select 0;
        deleteVehicle _spray;
        BloodLust_BloodSprays deleteAt 0;
    };
};


BloodLust_CreateBloodPoolObject =
{
    if(call BloodLust_IsMaxBloodSplattersReached) then
    {
        call BloodLust_RemoveOldBloodSplatter;
    };

    _pool = call BloodLust_CreateMediumBloodSplatterObject;

    BloodLust_BloodSplatters pushBack _pool;
    [selectRandom BloodLust_BloodPoolTextures, BloodLust_BloodPoolFramerate, false, false, _pool, {}] call BloodLust_AnimateObjectTexture;
    _pool;
};

BloodLust_InitVehicle =
{
    _vehicle = _this select 0;
    _vehicle addEventHandler ["Killed",
    {
        if(!BloodLust_IsBloodLustEnabled) exitWith {};
        {
            _this call _x;
        } foreach BloodLust_OnVehicleKilledPreEventHandlers;

        _this call BloodLust_OnVehicleKilled;

        {
            _this call _x;
        } foreach BloodLust_OnVehicleKilledPostEventHandlers;
    }];
};

BloodLust_OnVehicleKilled =
{
    _vehicle   = _this select 0;
    _killer = _this select 1;

    if(BloodLust_IsVehicleCrewVaporizationEnabled) then
    {
        [_vehicle] call BloodLust_VehicleCrewVaporization;
    };
};

BloodLust_VehicleCrewVaporization =
{
    _vehicle = _this select 0;
    _fuelExplosionPower = getNumber (configfile >> "CfgVehicles" >> (typeOf _vehicle) >> "fuelExplosionPower");
    if(_fuelExplosionPower >= 1) then
    {
        _crew = crew _vehicle;
        {
            [_x, _fuelExplosionPower] call BloodLust_VaporizeUnit;
        } foreach _crew;
    };
};

//Blood Lust -- Blood splatter mod.
//Copyright (C) 2016  Gavin N. Alvesteffer

_VaporizedUnitMessage =
{
	_unit = _this select 0;
	_damage = _this select 1;
	_isUnitVaporized = _unit getVariable ["BloodLust_IsVaporized", false];
    if(_isUnitVaporized) then
    {
       player globalChat (format ["Oh dear, %1 exploded :O", name _unit]);
    };
};

BloodLust_OnUnitExplosionPostEventHandlers pushBack _VaporizedUnitMessage;


BloodLust_VaporizeUnit =
{
    _unit = _this select 0;
    _gibForce = _this select 1;

    if(_unit getVariable ["BloodLust_IsVaporized", false]) exitWith {};

    _unit setVariable ["BloodLust_IsVaporized", true];
    _unit removeEventHandler ["HitPart", _unit getVariable ["BloodLust_HitPartEventHandlerIndex", -1]];
    _unit removeEventHandler ["Hit", _unit getVariable ["BloodLust_HitEventHandlerIndex", -1]];
    _unit removeEventHandler ["Explosion", _unit getVariable ["BloodLust_ExplosionEventHandlerIndex", -1]];
    _unit setDamage 1;
    _unit call BloodLust_GoreMistEffect;
    hideObject _unit;
    [selectRandom BloodLust_VaporizationSounds, _unit, false, getPosASL _unit, 30, 1.2 - (random 0.4), 100] call BloodLust_PlaySound;

    if(BloodLust_IsVaporizedHeatWaveEnabled) then
    {
        [_unit, 5] call BloodLust_RefractionEffect;
    };

    _gibSets = +BloodLust_VaporizationGibClassnames;
    _GetRandomGib =
    {
        _spawnableGibs = [];
        {
            _gibSetIndex = _x select 0;
            _spawnCount = _x select 2;
            _spawnLimit = _x select 3;
            if(_spawnCount < _spawnLimit) then
            {
                _spawnableGibs pushBack _x;
            };
        } foreach _gibSets;

        if(count _spawnableGibs == 0) exitWith
        {
            nil;
        };

        _gibSet = selectRandom _spawnableGibs;
        _gibSetIndex = _gibSet select 0;
        _className = _gibSet select 1;
        _spawnCount = _gibSet select 2;
        _spawnLimit = _gibSet select 3;

        (_gibSets select _gibSetIndex) set [2, _spawnCount + 1];
        _className;
    };

    _gibs = [];
    if (BloodLust_MaxGibs > 0) then
    {
        for "_i" from 1 to BloodLust_VaporizationGibIterations do
        {
            _gibClassname = call _GetRandomGib;
            if(isNil "_gibClassname") exitWith {};

            _jitter =
            [
                BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2)),
                BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2)),
                BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2))
            ];
            _gib = _gibClassname call BloodLust_CreateGibObject;
            _gibs pushBack _gib;
            _gib setVariable ["BloodLust_SourceUnit", _unit];
            _gib setDir (random 360);
            _gib setPosASL (getPosASL _unit);
            _gib setVelocity (_jitter vectorMultiply _gibForce);
            [_gib, BloodLust_GibBleedDuration, 0.1] call BloodLust_AttachSmearBleeding;

            if(_unit == player && BloodLust_IsVaporizedGibCamSwitchEnabled) then
            {
                (selectRandom _gibs) switchCamera "External";
            };

            if(BloodLust_IsVaporizedHeatWaveEnabled) then
            {
                [_gib, 30] call BloodLust_RefractionEffect;
            };

            {
                [_gib] call _x;
            } foreach BloodLust_OnGibCreatedEventHandlers;
        };
    };

    _bloodSplatters = [];
    _unitSurfaceIntersection = [getPosASL _unit, _unit, vehicle _unit] call BloodLust_GetSurfaceIntersection;
    _unitSurfaceDistance = _unitSurfaceIntersection select 0;
    _unitSurfaceNormal = _unitSurfaceIntersection select 1;
    _unitSurfacePosition = _unitSurfaceIntersection select 2;
    _unitIsIntersecting = _unitSurfaceIntersection select 3;
    _unitSurfaceIntersectingObject = _unitSurfaceIntersection select 4;
    if(_unitIsIntersecting) then
    {
        _largeSplatter = call BloodLust_CreateLargeBloodSplatterObject;
        _largeSplatter setObjectTexture [0, selectRandom BloodLust_LargeVaporizationBloodSplatters];
        _largeSplatter setDir (random 360);
        _largeSplatter setVectorUp _unitSurfaceNormal;
        _largeSplatter setPosASL (_unitSurfacePosition vectorAdd (_unitSurfaceNormal vectorMultiply 0.05));
        _bloodSplatters pushBack _largeSplatter;
        [_largeSplatter, _unitSurfaceIntersectingObject] call BloodLust_AssignSplatterToBuilding;
    };
    for "_i" from 1 to BloodLust_VaporizedBloodSplatterIterations do
    {
        _jitter =
        [
            BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2)),
            BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2)),
            BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2))
        ];
        _splatter =
        [
            _unit,
            getPosASL _unit,
            vectorNormalized _jitter,
            BloodLust_BloodSplatterIntersectionMaxDistance,
            random 360,
            selectRandom BloodLust_VaporizationBloodSplatters
        ] call BloodLust_CreateBloodSplatter;
        _bloodSplatters pushBack _splatter;
        if(BloodLust_IsVaporizedHeatWaveEnabled) then
        {
            [_splatter, 15] call BloodLust_RefractionEffect;
        };
    };

    {
        [_unit, _gibForce, _gibs, _bloodSplatters] call _x;
    } foreach BloodLust_OnUnitVaporizedEventHandlers;
};

BloodLust_IsAmmoInVaporizationWhitelist =
{
    _ammoClass = _this;
    _return    = false;

    {
        if(_ammoClass == _x || _ammoClass isKindOf _x) exitWith
        {
            _return = true;
        };
    } foreach BloodLust_VaporizationAmmoClassnames;

    _return;
};


//Blood Lust -- Blood splatter mod.
//Copyright (C) 2016  Gavin N. Alvesteffer

_UnitVehicleExplosion =
{
    _unit = _this select 0;
    _vehicle = vehicle _unit;
    _isUnitInVehicle = _vehicle != _unit;
    if(_isUnitInVehicle && damage _vehicle == 1) then
    {
        _fuelExplosionPower = getNumber (configfile >> "CfgVehicles" >> (typeOf _vehicle) >> "fuelExplosionPower");
        if(_fuelExplosionPower >= 1) then
        {
            [_unit, _fuelExplosionPower] call BloodLust_VaporizeUnit;
        };
    };
};

BloodLust_OnUnitKilledPostEventHandlers pushBack _UnitVehicleExplosion;


//Adds BloodLust effects to unit.
BloodLust_InitUnit =
{
    _unit = _this select 0;

    _hitPartEventHandlerIndex = _unit addEventHandler ["HitPart",
    {
        if(!BloodLust_IsBloodLustEnabled || count _this > 1) exitWith {}; //Probably an explosion -- let the explosion handler deal with this.

        _unit = (_this select 0) select 0;

        if (!BloodLust_IsBloodLustEnabledForDeadUnits && !alive _unit) exitWith {};
        if (!BloodLust_IsSplatteringEnabledForUnitsInVehicles && vehicle _unit != _unit) exitWith {};

        if((position _unit) distance (positionCameraToWorld [0, 0, 0]) <= BloodLust_BloodLustActivationDistance) then
        {
            {
                _this call _x;
            } foreach BloodLust_OnUnitHitPartPreEventHandlers;

            _this call BloodLust_OnUnitHitPart;

            {
                _this call _x;
            } foreach BloodLust_OnUnitHitPartPostEventHandlers;
        };
    }];

    _explosionEventHandlerIndex = _unit addEventHandler ["Explosion",
    {
        if(!BloodLust_IsBloodLustEnabled) exitWith {};
        _unit = _this select 0;
        if((position _unit) distance (positionCameraToWorld [0, 0, 0]) <= BloodLust_BloodLustActivationDistance) then
        {
            {
                _this call _x;
            } foreach BloodLust_OnUnitExplosionPreEventHandlers;

            _this call BloodLust_OnUnitExplosion;

            {
                _this call _x;
            } foreach BloodLust_OnUnitExplosionPostEventHandlers;
        };
    }];

    _killedEventHandlerIndex = _unit addEventHandler ["Killed",
    {
        if(!BloodLust_IsBloodLustEnabled) exitWith {};
        {
            _this call _x;
        } foreach BloodLust_OnUnitKilledPreEventHandlers;

        _this call BloodLust_OnUnitKilled;

        {
            _this call _x;
        } foreach BloodLust_OnUnitKilledPostEventHandlers;
    }];

    _hitEventHandlerIndex = _unit addEventHandler ["Hit",
    {
        if(!BloodLust_IsBloodLustEnabled) exitWith {};

        _unit = _this select 0;

        if(!BloodLust_IsBloodLustEnabledForDeadUnits && !alive _unit) exitWith {};

        if((position _unit) distance (positionCameraToWorld [0, 0, 0]) <= BloodLust_BloodLustActivationDistance) then
        {
            {
                _this call _x;
            } foreach BloodLust_OnUnitHitPreEventHandlers;

            _this call BloodLust_OnUnitHit;

            {
                _this call _x;
            } foreach BloodLust_OnUnitHitPostEventHandlers;
        };
    }];

    _unit setVariable ["BloodLust_HitPartEventHandlerIndex", _hitPartEventHandlerIndex];
    _unit setVariable ["BloodLust_ExplosionEventHandlerIndex", _explosionEventHandlerIndex];
    _unit setVariable ["BloodLust_KilledEventHandlerIndex", _killedEventHandlerIndex];
    _unit setVariable ["BloodLust_HitEventHandlerIndex", _hitEventHandlerIndex];
};

BloodLust_OnUnitHit =
{
    _unit = _this select 0;
    _causedBy = _this select 1;
    _damage = _this select 2;

    if(BloodLust_IsUnitVehicleCollisionEffectsEnabled) then
    {
        _isUnitHitByVehicle = [_unit, _causedBy] call BloodLust_IsUnitHitByVehicle;
        if(_isUnitHitByVehicle) then
        {
            [_unit, vehicle _causedBy, _damage] call BloodLust_UnitHitByVehicle;
        };
    };

    if(BloodLust_IsFallingVaporizationEnabled) then
    {
        [_unit, _causedBy] call BloodLust_UnitFallVaporization;
    };
};

BloodLust_OnUnitExplosion =
{
    _unit = _this select 0;
    _damage = _this select 1;

    if(_unit getVariable ["BloodLust_IsVaporized", false]) exitWith {};

    if(BloodLust_IsVaporizationEnabled && _damage >= BloodLust_VaporizationDamageThreshold) exitWith
    {
        [_unit, _damage * BloodLust_ExplosionGibForceMultiplier] call BloodLust_VaporizeUnit;
    };

    if(_damage >= BloodLust_ExplosionDamageThreshold) then
    {
        _splatterCount = _damage * BloodLust_ExplosionBloodSplatterIterationMultiplier;
        for [{_i = 0}, {_i < _splatterCount}, {_i = _i + 1}] do
        {
            _jitter =
            [
                BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2)),
                BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2)),
                BloodLust_VaporizedBloodSplatterJitterAmount - (random (BloodLust_VaporizedBloodSplatterJitterAmount * 2))
            ];
            _splatter =
            [
                _unit,
                getPosASL _unit,
                vectorNormalized _jitter,
                BloodLust_BloodSplatterIntersectionMaxDistance,
                random 360,
                selectRandom BloodLust_VaporizationBloodSplatters
            ] call BloodLust_CreateBloodSplatter;
        };
    };
};

BloodLust_OnUnitKilled =
{
    _unit   = _this select 0;
    _killer = _this select 1;

    if(BloodLust_IsFallingVaporizationEnabled) then
    {
        _isUnitVaporized = [_unit, _killer] call BloodLust_UnitFallVaporization;
    };
};

//Pass event args from "HitPart" event.
//Example: _this call OnUnitHitPart;
BloodLust_OnUnitHitPart =
{
    _hitSelections = _this;
    _unit = (_hitSelections select 0) select 0;

    if(_unit getVariable ["BloodLust_IsVaporized", false]) exitWith {};

    _hitSelectionsFiltered = _hitSelections select
    {
        _return    = false;
        _ammoClass = (_x select 6) select 4;
        if(_ammoClass != "") then
        {
            _return = true;
        };
        _return;
    };

    if (count _hitSelectionsFiltered == 0) exitWith {};

    _hitSelection = _hitSelectionsFiltered select 0;
    _target       = _hitSelection select 0;
    _shooter      = _hitSelection select 1;
    _bullet       = _hitSelection select 2;
    _hitPosition  = _hitSelection select 3;
    _velocity     = _hitSelection select 4;
    _selections   = _hitSelection select 5;
    _ammo         = _hitSelection select 6;
    _direction    = _hitSelection select 7;
    _radius       = _hitSelection select 8;
    _surface      = _hitSelection select 9;
    _isDirectHit  = _hitSelection select 10;
    _ammoDamage   = _ammo select 0;
    _ammoCaliber =  getNumber(configFile >> "CfgAmmo" >> (_ammo select 4) >> "caliber");
    _bloodSplatterIterations = ((BloodLust_BloodSplatterIterationCaliberMultiplier * _ammoCaliber) * BloodLust_BloodSplatterIterations) max 1;

    if(BloodLust_IsBloodSprayEnabled && (random 1) <= BloodLust_BloodSprayProbability) then
    {
        for "_i" from 1 to BloodLust_BloodSprayIterations do
        {
            _sprayJitter =
            [
                BloodLust_BloodSprayJitterAmount - (random (BloodLust_BloodSprayJitterAmount * 2)),
                BloodLust_BloodSprayJitterAmount - (random (BloodLust_BloodSprayJitterAmount * 2)),
                BloodLust_BloodSprayJitterAmount - (random (BloodLust_BloodSprayJitterAmount * 2))
            ];

            [_hitPosition, (vectorDir _bullet) vectorAdd _sprayJitter, (vectorUp _bullet) vectorAdd _sprayJitter] call BloodLust_CreateBloodSpray;
        };
    };

    if(random 1 <= BloodLust_BloodSplatterProbability) then
    {
        _splatterTextures = [_target, _selections] call BloodLust_GetSplatterTextures;
        if(count _splatterTextures == 0) exitWith {};
        _splatterJitter =
        [
            BloodLust_BloodSplatterJitterAmount - (random (BloodLust_BloodSplatterJitterAmount * 2)),
            BloodLust_BloodSplatterJitterAmount - (random (BloodLust_BloodSplatterJitterAmount * 2)),
            BloodLust_BloodSplatterJitterAmount - (random (BloodLust_BloodSplatterJitterAmount * 2))
        ];

        // Splatter that spawns under the character.
        if (BloodLust_IsUnderCharacterBloodSplatterEnabled) then
        {
            [
                _target,
                _hitPosition,
                _splatterJitter,
                BloodLust_BloodSplatterIntersectionMaxDistance,
                (direction _bullet + 90) + random BloodLust_BloodSplatterAngleJitterAmount,
                selectRandom _splatterTextures,
                call BloodLust_CreateMediumBloodSplatterObject
            ] call BloodLust_CreateBloodSplatter;
        };

        // Blood Trail creation on death.
        if (BloodLust_IsBloodTrailEnabled && random 1 <= BloodLust_BloodTrailProbability) then
        {
            {
                if (BloodLust_BloodTrailTriggeringSelections find _x != -1) exitWith
                {
                    [_target, _x, BloodLust_BloodTrailDuration] call BloodLust_StartBloodTrail;
                }
            } forEach _selections;
        };

        for "_i" from 1 to _bloodSplatterIterations do
        {
            // Intersecting surface splatter.
            [
                _target,
                _hitPosition,
                vectorNormalized _velocity vectorAdd _splatterJitter,
                BloodLust_BloodSplatterIntersectionMaxDistance,
                (direction _bullet + 90) + random BloodLust_BloodSplatterAngleJitterAmount,
                selectRandom _splatterTextures
            ] call BloodLust_CreateBloodSplatter;
        };
    };

    if(BloodLust_IsBleedingEnabled && alive _unit) then
    {
       {
           [_hitSelection, BloodLust_BleedDuration, BloodLust_BleedFrequency, BloodLust_BleedFrequencyVariance] call BloodLust_MakeUnitBleed;
       } foreach _hitSelectionsFiltered;
    };
};

BloodLust_UnitFallVaporization =
{
    _unit = _this select 0;
    _killer = _this select 1;
    _isUnitOnFoot = vehicle _unit == _unit;
    _unitVelocityMagnitude = vectorMagnitude (velocity _unit);
    _isUnitVaporized = false;
    if(_unit == _killer && _isUnitOnFoot && _unitVelocityMagnitude >= BloodLust_FallingVaporizationSpeedThreshold) then
    {
        [_unit, _unitVelocityMagnitude * BloodLust_FallingVaporizationGibSpeedScalar] call BloodLust_VaporizeUnit;
        _isUnitVaporized = true;
    };
    _isUnitVaporized;
};

BloodLust_IsUnitHitByVehicle =
{
    _unit = _this select 0;
    _damageSourceUnit = _this select 1;
    _vehicle = vehicle _damageSourceUnit; //ToDo: Received report that this statement can cause an error: Type string received, expected object.
    _vehicleSize = sizeOf (typeOf _vehicle);
    _isUnitOnFoot = vehicle _unit == _unit;
    _isDamageSourceVehicle = _vehicle != _damageSourceUnit;
    _isUnitNearVehicle = _unit distance _vehicle <= _vehicleSize;
    _return = _isUnitOnFoot && _isDamageSourceVehicle && _isUnitNearVehicle && _vehicle call BloodLust_GetVelocityMagnitude >= 15;
    _return;
};

BloodLust_UnitHitByVehicle =
{
    _unit = _this select 0;
    _vehicle = _this select 1;
    _damage = _this select 2;
    _vehicleSpeed = _vehicle call BloodLust_GetVelocityMagnitude;

    [selectRandom BloodLust_UnitVehicleCollisionSounds, _vehicle, false, getPosASL _vehicle, (_vehicle call BloodLust_GetVelocityMagnitude) * 0.5, 1.2 - (random 0.4), 50] call BloodLust_PlaySound;
    if(_vehicleSpeed >= BloodLust_UnitVehicleVaporizationCollisionSpeed && random 1 <= BloodLust_UnitVehicleVaporizationProbability) then
    {
        [_unit, log _vehicleSpeed] call BloodLust_VaporizeUnit;
    }
    else
    {
        [_unit, BloodLust_UnitVehicleCollisionBleedDuration, 0.1] call BloodLust_AttachBleeding;
    };
};

//Blood Lust -- Blood splatter mod.
//Copyright (C) 2016  Gavin N. Alvesteffer

//Make units go splat when they hit the ground at high speed.
BloodLust_OnUnitKilledPostEventHandlers pushBack
{
    _unit = _this select 0;
    _killer = _this select 1;
    _isUnitOnFoot = vehicle _unit == _unit;
    _unitVelocity = velocity _unit;
    _unitVelocityMagnitude = vectorMagnitude _unitVelocity;
    if(_unit == _killer && _isUnitOnFoot && _unitVelocityMagnitude >= 20) then
    {
        [_unit, _unitVelocityMagnitude * 0.2] call BloodLust_VaporizeUnit;
    };
};
