/*
    üöÄ OPTIMIZACI√ìN DE RENDIMIENTO AVANZADA PARA ARMA 3 üöÄ
    Versi√≥n: 3.3 - L√≠mite Estricto + Optimizaci√≥n Completa (Simplificado)

    üåü Script: Mejoras VFX 
    üë®‚Äçüíª Autor: Vianna & Enkeli
    üìÖ Creaci√≥n: 2025-05-20
*/

// ===== DEFINICI√ìN DE PAR√ÅMETROS Y VARIABLES GLOBALES =====
if (isNil "_this") then {_this = [300, 2000, true, true, true, true]};
params [
    ["_radioSimulacionParam", 300, [0]],         // Radio de simulaci√≥n completa
    ["_distanciaMaximaParam", 2000, [0]],        // Distancia m√°xima para optimizaci√≥n
    ["_optimizarIAParam", true, [true]],         // Activar optimizaci√≥n de IA
    ["_optimizarVehiculosParam", true, [true]],  // Activar optimizaci√≥n de veh√≠culos
    ["_optimizarObjetosParam", true, [true]],    // Activar optimizaci√≥n de objetos
    ["_optimizarDecoracionesParam", true, [true]] // Activar optimizaci√≥n de decoraciones
];

// üîç Comprobaci√≥n de CBA y ACE
OPT_tieneCBA = isClass (configFile >> "CfgPatches" >> "cba_main");
OPT_tieneACE = isClass (configFile >> "CfgPatches" >> "ace_main");

// üõ†Ô∏è Funci√≥n auxiliar para compatibilidad
OPT_fnc_pushBackUnique = {
    params ["_array", "_elemento"];
    if !(_elemento in _array) then {
        _array pushBack _elemento;
    };
    _array
};

// üìù Variables globales para mantener los par√°metros accesibles
OPT_radioSimulacion = _radioSimulacionParam;
OPT_distanciaMaxima = _distanciaMaximaParam;
OPT_optimizarIA = _optimizarIAParam;
OPT_optimizarVehiculos = _optimizarVehiculosParam;
OPT_optimizarObjetos = _optimizarObjetosParam;
OPT_optimizarDecoraciones = _optimizarDecoracionesParam;

// üìå Otras variables globales necesarias
OPT_activo = true;
OPT_entidadesGestionadas = [];
OPT_cacheTiempo = time;
OPT_intervaloCacheado = 5;
OPT_ultimaPosJugador = [0,0,0];
OPT_distanciaMovimiento = 50;
OPT_sectores = [];
OPT_sectorActual = "";
OPT_marcoSectores = 1000;
OPT_nivelLog = 0;
OPT_vehiculoActual = objNull;
OPT_radioSimulacionOriginal = OPT_radioSimulacion;
OPT_cadaveresPendientes = [];
OPT_tiempoRagdoll = 5; // Tiempo para permitir la f√≠sica ragdoll (segundos)
OPT_enHeadless = !hasInterface && !isDedicated;
OPT_eventosImportantes = [];
OPT_ultimoEvento = time;
OPT_objetosPequenos = [];
OPT_clasesDecorativas = ["Furniture_base_F", "Items_base_F", "House_Small_F", "HouseDecorations_base_F", "Tableware_base_F"];
OPT_ultimaLimpieza = time;
OPT_radioDecoraciones = 50; // Radio para optimizaci√≥n de decoraciones (m√°s agresivo)
OPT_version = "3.3";
OPT_radioJugadores = 1000; // Radio para detectar jugadores cercanos
OPT_todosJugadores = []; // Array para almacenar todos los jugadores

// === VARIABLES PARA L√çMITE DE VISIBILIDAD ===
OPT_limiteVisibilidad = 1300; // L√≠mite en metros para hacer objetos invisibles
OPT_distanciaVisionForzada = 1200; // Distancia de visi√≥n forzada
OPT_altitudVuelo = 50; // Metros sobre el terreno para considerar que est√° volando
OPT_estaVolando = false; // Estado actual de vuelo del jugador
OPT_viewDistanciaOriginal = viewDistance; // Guardar vista original
OPT_objectViewDistanciaOriginal = []; // Guardaremos el array completo aqu√≠
OPT_ultimaComprobacionVuelo = time; // √öltima vez que comprobamos si est√° volando
OPT_intervaloComprobacionVuelo = 1; // Comprobar cada segundo si est√° volando
OPT_procesarLimiteVisibilidad = true; // Si se debe procesar el l√≠mite de visibilidad
OPT_ultimaForzadoVista = time; // √öltimo tiempo que se forz√≥ la vista
OPT_intervaloForzadoVista = 1; // Intervalo para forzar la vista (cada segundo)
OPT_objetosLejanos = []; // Objetos fuera del l√≠mite de visibilidad
OPT_ultimoEscaneoObjetos = time; // √öltimo escaneo de objetos lejanos
OPT_intervaloEscaneoObjetos = 5; // Intervalo para escanear objetos lejanos
OPT_clasesTerrenoExcluidas = ["Land_VR_Shape_01_cube_1m_F"]; // Objetos que no se deben ocultar
OPT_displayListo = false; // Indica si el display ya est√° listo

// ===== SISTEMA DE LOG VAC√çO =====
OPT_fnc_log = {
    // Funci√≥n vac√≠a para eliminar todos los mensajes de debug
};

// ===== FUNCI√ìN PARA COMPROBAR SI EL JUGADOR EST√Å VOLANDO =====
OPT_fnc_estaVolando = {
    if (isNull player) then {
        false
    } else {
        // Si est√° en un veh√≠culo a√©reo
        if (vehicle player != player) then {
            private _veh = vehicle player;
            // Usar varias comprobaciones para mayor compatibilidad
            if (_veh isKindOf "Air" || _veh isKindOf "Helicopter" || _veh isKindOf "Plane") then {
                true
            } else {
                // O si est√° muy por encima del terreno
                private _altitud = (getPosASL player) select 2;
                private _altitudTerreno = getTerrainHeightASL (getPos player);
                private _diferencia = _altitud - _altitudTerreno;
                (_diferencia > OPT_altitudVuelo)
            };
        } else {
            // O si est√° muy por encima del terreno
            private _altitud = (getPosASL player) select 2;
            private _altitudTerreno = getTerrainHeightASL (getPos player);
            private _diferencia = _altitud - _altitudTerreno;
            (_diferencia > OPT_altitudVuelo)
        };
    };
};

// ===== FUNCI√ìN PARA FORZAR DISTANCIA DE VISI√ìN (SIMPLIFICADA) =====
OPT_fnc_forzarDistanciaVision = {
    // Versi√≥n super simplificada para evitar errores
    setViewDistance OPT_distanciaVisionForzada;
    setObjectViewDistance OPT_distanciaVisionForzada;
    
    // Intentar establecer la configuraci√≥n de terreno si est√° disponible
    if (!isNil "setTerrainGrid") then {
        setTerrainGrid 25;
    };
};

// ===== FUNCI√ìN PARA OCULTAR OBJETOS FUERA DEL L√çMITE (SIMPLIFICADA) =====
OPT_fnc_ocultarObjetosLejanos = {
    // Solo ejecutar si tenemos interfaz y el jugador existe
    if (!hasInterface) then {
        // Nada que hacer en servidor sin interfaz
    } else {
        if (isNull player) then {
            // Nada que hacer si el jugador no existe
        } else {
            private _posJugador = getPosATL player;
            
            // Restaurar visibilidad si est√° volando
            if (OPT_estaVolando) then {
                {
                    if (!isNull _x) then {
                        _x hideObjectGlobal false;
                        _x enableSimulationGlobal true;
                    };
                } forEach OPT_objetosLejanos;
                
                // Limpiar la lista
                OPT_objetosLejanos = [];
            } else {
                // No est√° volando, procesar ocultar objetos
                if (time > OPT_ultimoEscaneoObjetos + OPT_intervaloEscaneoObjetos) then {
                    OPT_ultimoEscaneoObjetos = time;
                    
                    // Categor√≠as a escanear
                    private _categorias = ["Building", "House", "Static"];
                    private _objetosEncontrados = [];
                    
                    // Escanear objetos
                    {
                        private _categoria = _x;
                        private _objetos = nearestObjects [_posJugador, [_categoria], OPT_limiteVisibilidad * 2];
                        
                        {
                            if (!isNull _x && {!(_x isKindOf "Logic")} && {_x != player}) then {
                                _objetosEncontrados pushBack _x;
                            };
                        } forEach _objetos;
                    } forEach _categorias;
                    
                    // Restaurar visibilidad de objetos anteriores
                    {
                        if (!isNull _x) then {
                            _x hideObjectGlobal false;
                            _x enableSimulationGlobal true;
                        };
                    } forEach OPT_objetosLejanos;
                    
                    // Reiniciar lista
                    OPT_objetosLejanos = [];
                    
                    // Procesar nuevos objetos encontrados
                    {
                        private _distancia = _x distance _posJugador;
                        
                        // Si est√° fuera del l√≠mite, ocultar
                        if (_distancia > OPT_limiteVisibilidad) then {
                            OPT_objetosLejanos pushBack _x;
                            _x hideObjectGlobal true;
                            _x enableSimulationGlobal false;
                        };
                    } forEach _objetosEncontrados;
                } else {
                    // Si no es tiempo de escanear, solo reforzar ocultaci√≥n
                    {
                        if (!isNull _x) then {
                            _x hideObjectGlobal true;
                            _x enableSimulationGlobal false;
                        };
                    } forEach OPT_objetosLejanos;
                };
            };
        };
    };
};

// üó∫Ô∏è Generar sectores del mapa
OPT_fnc_generarSectores = {
    private _mapSize = worldSize;
    private _numSectores = ceil (_mapSize / OPT_marcoSectores);
    
    for "_x" from 0 to (_numSectores - 1) do {
        for "_y" from 0 to (_numSectores - 1) do {
            private _sectorID = format ["sector_%1_%2", _x, _y];
            private _centro = [
                (_x * OPT_marcoSectores) + (OPT_marcoSectores / 2),
                (_y * OPT_marcoSectores) + (OPT_marcoSectores / 2),
                0
            ];
            OPT_sectores pushBack [_sectorID, _centro];
        };
    };
};

// üìç Obtener sector actual del jugador
OPT_fnc_obtenerSectorJugador = {
    private _posJugador = if (OPT_enHeadless) then {
        missionNamespace getVariable ["OPT_posicionJugadorGlobal", [0,0,0]]
    } else {
        if (!isNull player) then {
            getPosATL player
        } else {
            [0,0,0]
        };
    };
    
    private _x = floor ((_posJugador select 0) / OPT_marcoSectores);
    private _y = floor ((_posJugador select 1) / OPT_marcoSectores);
    private _sectorID = format ["sector_%1_%2", _x, _y];
    
    if (_sectorID != OPT_sectorActual) then {
        OPT_sectorActual = _sectorID;
    };
    
    _sectorID
};

// üë• Verificar si hay jugadores cercanos a la entidad
OPT_fnc_hayJugadoresCercanos = {
    params ["_entidad"];
    
    private _result = false;
    
    {
        if (_x distance _entidad < OPT_radioJugadores) exitWith {
            _result = true;
        };
    } forEach OPT_todosJugadores;
    
    _result
};

// üìä Calcular prioridad basada en distancia, jugadores cercanos y sector
OPT_fnc_calcularPrioridad = {
    params ["_entidad"];
    
    // Comprobar si hay jugadores cercanos (dentro de 1000m)
    private _hayJugadoresCercanos = [_entidad] call OPT_fnc_hayJugadoresCercanos;
    
    // Si no hay jugadores cercanos, poner prioridad m√°s baja (para ocultar)
    if (!_hayJugadoresCercanos) then {
        99 // Sin prioridad - ser√° ocultado
    } else {
        // Obtener posici√≥n del jugador local para c√°lculos
        private _posJugador = if (OPT_enHeadless) then {
            missionNamespace getVariable ["OPT_posicionJugadorGlobal", [0,0,0]]
        } else {
            if (!isNull player) then {
                getPosATL player
            } else {
                [0,0,0]
            };
        };
        
        private _distancia = _posJugador distance _entidad;
        
        // Si se aplica l√≠mite de visibilidad y el jugador no est√° volando
        if (!OPT_estaVolando && hasInterface && OPT_procesarLimiteVisibilidad) then {
            if (_distancia > OPT_limiteVisibilidad) then {
                99 // Fuera del l√≠mite, ocultar
            } else {
                // Dentro del l√≠mite, calcular prioridad normal
                private _prioridad = 3; // Por defecto: baja prioridad
                
                // Verificar si es un objeto decorativo
                private _esDecoracion = false;
                if (OPT_optimizarDecoraciones) then {
                    {
                        if (_entidad isKindOf _x) exitWith {
                            _esDecoracion = true;
                        };
                    } forEach OPT_clasesDecorativas;
                    
                    // Si es decoraci√≥n, usar un radio m√°s peque√±o
                    if (_esDecoracion) then {
                        if (_distancia < OPT_radioDecoraciones) then {
                            _prioridad = 1;
                        } else {
                            _prioridad = 3; // Baja prioridad para decoraciones
                        };
                    };
                };
                
                // Si no es decoraci√≥n, usar l√≥gica normal
                if (!_esDecoracion) then {
                    // Prioridad basada en distancia al jugador
                    if (_distancia < OPT_radioSimulacion) then {
                        _prioridad = 1; // Alta prioridad: simulaci√≥n completa
                    } else {
                        if (_distancia < OPT_radioSimulacion * 2) then {
                            _prioridad = 2; // Media prioridad
                        };
                    };
                };
                
                // Comprobar si est√° cerca de un evento importante
                {
                    _x params ["_pos", "_radio", "_tiempoFin"];
                    
                    if (time <= _tiempoFin) then {
                        private _distEvento = _pos distance _entidad;
                        if (_distEvento < _radio) then {
                            // Cerca de un evento importante, aumentar prioridad
                            _prioridad = _prioridad - 1;
                            _prioridad = _prioridad max 1;
                        };
                    };
                } forEach OPT_eventosImportantes;
                
                // Ajustes por tipo de entidad
                if (_entidad isKindOf "CAManBase") then {
                    // Prioridad adicional para unidades en combate
                    if (behaviour _entidad == "COMBAT") then {
                        _prioridad = _prioridad max 2;
                    };
                    
                    // Prioridad adicional para l√≠deres de grupo
                    if (leader group _entidad == _entidad) then {
                        _prioridad = _prioridad max 2;
                    };
                } else {
                    if (_entidad isKindOf "AllVehicles") then {
                        // Veh√≠culos con tripulaci√≥n siempre tienen mayor prioridad
                        if (count crew _entidad > 0) then {
                            _prioridad = _prioridad max 2;
                        };
                    };
                };
                
                _prioridad
            };
        } else {
            // No aplicamos l√≠mite de visibilidad, calcular prioridad normal
            private _prioridad = 3; // Por defecto: baja prioridad
            
            if (_distancia < OPT_radioSimulacion) then {
                _prioridad = 1; // Alta prioridad: simulaci√≥n completa
            } else {
                if (_distancia < OPT_radioSimulacion * 2) then {
                    _prioridad = 2; // Media prioridad
                };
            };
            
            _prioridad
        };
    };
};

// üéÆ Aplicar optimizaci√≥n basada en prioridad
OPT_fnc_aplicarOptimizacion = {
    params ["_entidad", "_prioridad"];
    
    // Si ya est√° muerto, aplicar otra l√≥gica
    if (!alive _entidad && _entidad isKindOf "CAManBase") then {
        // Verificar si a√∫n est√° en periodo de ragdoll
        private _tiempoMuerte = _entidad getVariable ["OPT_tiempoMuerte", 0];
        private _hayJugadoresCercanos = [_entidad] call OPT_fnc_hayJugadoresCercanos;
        
        if (_tiempoMuerte > 0 && (time - _tiempoMuerte < OPT_tiempoRagdoll)) then {
            // A√∫n en periodo de ragdoll, dejar la simulaci√≥n activa
            _entidad enableSimulationGlobal true;
            _entidad hideObjectGlobal false;
        } else {
            // Si no hay jugadores cercanos, ocultar cad√°veres
            if (!_hayJugadoresCercanos) then {
                _entidad enableSimulationGlobal false;
                _entidad hideObjectGlobal true;
            } else {
                // Para cad√°veres, simplificamos la simulaci√≥n pero no los ocultamos
                _entidad enableSimulationGlobal false;
                _entidad hideObjectGlobal false;
            };
        };
    } else {
        // Para objetos normales
        switch (_prioridad) do {
            // ‚≠ê Alta prioridad: simulaci√≥n completa
            case 1: {
                _entidad enableSimulationGlobal true;
                _entidad hideObjectGlobal false;
                
                // Para IA, restauramos comportamiento completo
                if (_entidad isKindOf "CAManBase" && {!isPlayer _entidad}) then {
                    // Restaurar FSM de IA si fue simplificado
                    if (_entidad getVariable ["OPT_IASimplificada", false]) then {
                        _entidad setVariable ["OPT_IASimplificada", false];
                        // Restaurar comportamiento normal
                        _entidad allowFleeing 0.1;
                        _entidad enableAI "PATH";
                        _entidad enableAI "FSM";
                        _entidad enableAI "TARGET";
                    };
                };
                
                // Para efectos, restaurar si estaban desactivados
                if (_entidad isKindOf "WeaponHolder") then {
                    _entidad enableSimulationGlobal true;
                };
            };
            
            // ‚úÖ Media prioridad: simulaci√≥n reducida, visible
            case 2: {
                _entidad enableSimulationGlobal true;
                _entidad hideObjectGlobal false;
                
                // Para IA, simplificamos comportamiento
                if (_entidad isKindOf "CAManBase" && {!isPlayer _entidad}) then {
                    if !(_entidad getVariable ["OPT_IASimplificada", false]) then {
                        _entidad setVariable ["OPT_IASimplificada", true];
                        // Simplificar comportamiento
                        _entidad allowFleeing 1;
                        
                        // Si no est√° en combate, reducir a√∫n m√°s
                        if (behaviour _entidad != "COMBAT") then {
                            _entidad disableAI "FSM";
                        };
                    };
                };
            };
            
            // üü° Baja prioridad: simulaci√≥n m√≠nima, visible a distancia
            case 3: {
                _entidad enableSimulationGlobal false;
                _entidad hideObjectGlobal false;
                
                // Para IA, guardar estado si hace falta
                if (_entidad isKindOf "CAManBase" && {!isPlayer _entidad}) then {
                    if !(_entidad getVariable ["OPT_IASimplificada", true]) then {
                        _entidad setVariable ["OPT_IASimplificada", true];
                    };
                    
                    // Desactivar IA compleja
                    _entidad disableAI "FSM";
                    _entidad disableAI "TARGET";
                };
            };
            
            // Sin prioridad: desactivar y ocultar (solo cuando NO hay jugadores cerca o fuera de l√≠mite de visibilidad)
            default {
                _entidad enableSimulationGlobal false;
                _entidad hideObjectGlobal true;
            };
        };
    };
};

// üîç Funci√≥n para procesar entidad individual
OPT_fnc_procesarEntidad = {
    params ["_entidad"];
    
    // Ignorar jugadores y objetos no gestionables
    if (isPlayer _entidad) then {
        // Nada que hacer con jugadores
    } else {
        if !(_entidad in OPT_entidadesGestionadas) then {
            // Nada que hacer con objetos no gestionados
        } else {
            // Calcular prioridad
            private _prioridad = [_entidad] call OPT_fnc_calcularPrioridad;
            
            // Aplicar optimizaci√≥n
            [_entidad, _prioridad] call OPT_fnc_aplicarOptimizacion;
        };
    };
};

// üíÄ Funci√≥n para procesar ragdoll de cad√°veres
OPT_fnc_procesarCadaveres = {
    // Procesar cada cad√°ver pendiente
    {
        private _cadaver = _x;
        private _tiempoMuerte = _cadaver getVariable ["OPT_tiempoMuerte", 0];
        
        // Si ya pas√≥ el tiempo de ragdoll
        if (time - _tiempoMuerte >= OPT_tiempoRagdoll) then {
            // Procesar el cad√°ver normalmente
            [_cadaver] call OPT_fnc_procesarEntidad;
            OPT_cadaveresPendientes = OPT_cadaveresPendientes - [_cadaver];
        };
    } forEach OPT_cadaveresPendientes;
    
    // Limpiar cad√°veres nulos
    OPT_cadaveresPendientes = OPT_cadaveresPendientes select {!isNull _x};
};

// ‚ûï Registrar entidad para gesti√≥n
OPT_fnc_registrarEntidad = {
    params ["_entidad"];
    
    // No registrar jugadores, entidades nulas o ya registradas
    if (isNull _entidad) then {
        // No hacer nada con entidades nulas
    } else {
        if (isPlayer _entidad) then {
            // No hacer nada con jugadores
        } else {
            if (_entidad in OPT_entidadesGestionadas) then {
                // Ya est√° registrada
            } else {
                // Para decoraciones, filtrar y registrar si corresponde
                if (OPT_optimizarDecoraciones) then {
                    {
                        if (_entidad isKindOf _x) exitWith {
                            if (OPT_tieneCBA) then {
                                OPT_objetosPequenos pushBackUnique _entidad;
                                OPT_entidadesGestionadas pushBackUnique _entidad;
                            } else {
                                [OPT_objetosPequenos, _entidad] call OPT_fnc_pushBackUnique;
                                [OPT_entidadesGestionadas, _entidad] call OPT_fnc_pushBackUnique;
                            };
                            _entidad setVariable ["OPT_EsDecoracion", true];
                        };
                    } forEach OPT_clasesDecorativas;
                };
                
                // Si no era decoraci√≥n o ya fue registrada como tal
                if !(_entidad in OPT_entidadesGestionadas) then {
                    // Registrar y guardar estado original
                    OPT_entidadesGestionadas pushBack _entidad;
                };
                
                // Variables iniciales para seguimiento
                _entidad setVariable ["OPT_IASimplificada", false];
                _entidad setVariable ["OPT_ultimoProcesado", time];
                _entidad setVariable ["OPT_Muerto", false];
                _entidad setVariable ["OPT_tiempoMuerte", 0];
                
                // Procesar inicialmente
                [_entidad] call OPT_fnc_procesarEntidad;
                
                // Agregar controlador para muerte
                if (_entidad isKindOf "CAManBase") then {
                    _entidad addEventHandler ["Killed", {
                        params ["_unit"];
                        _unit setVariable ["OPT_Muerto", true];
                        _unit setVariable ["OPT_tiempoMuerte", time];
                        
                        // A√±adir a la lista de cad√°veres pendientes para permitir ragdoll
                        if (OPT_tieneCBA) then {
                            OPT_cadaveresPendientes pushBackUnique _unit;
                        } else {
                            [OPT_cadaveresPendientes, _unit] call OPT_fnc_pushBackUnique;
                        };
                        
                        // Asegurarse que la simulaci√≥n est√° activada durante el tiempo de ragdoll
                        _unit enableSimulationGlobal true;
                        
                        // Registrar como evento importante
                        [getPosATL _unit, 30, 15] call OPT_fnc_registrarEvento;
                    }];
                };
            };
        };
    };
};

// üéØ Sistema de eventos importantes
OPT_fnc_registrarEvento = {
    params ["_posicion", "_radio", "_duracion"];
    
    OPT_eventosImportantes pushBack [_posicion, _radio, time + _duracion];
    OPT_ultimoEvento = time;
    
    // Forzar actualizaci√≥n de entidades cercanas
    {
        if (_x distance _posicion < _radio * 1.5) then {
            [_x] call OPT_fnc_procesarEntidad;
        };
    } forEach OPT_entidadesGestionadas;
};

// üîÑ Actualizar cach√©s
OPT_fnc_actualizarCache = {
    if (time < OPT_cacheTiempo + OPT_intervaloCacheado) then {
        // Nada que hacer todav√≠a
    } else {
        OPT_cacheTiempo = time;
        
        // Compartir posici√≥n del jugador con headless clients
        if (!OPT_enHeadless && hasInterface && !isNull player) then {
            missionNamespace setVariable ["OPT_posicionJugadorGlobal", getPosATL player, true];
        };
        
        // Forzar distancia de visi√≥n si tiene interfaz
        if (hasInterface && !isNull player) then {
            if (time > OPT_ultimaForzadoVista + OPT_intervaloForzadoVista) then {
                OPT_ultimaForzadoVista = time;
                call OPT_fnc_forzarDistanciaVision;
            };
            
            // Actualizar estado de vuelo cada cierto tiempo
            if (time > OPT_ultimaComprobacionVuelo + OPT_intervaloComprobacionVuelo) then {
                OPT_ultimaComprobacionVuelo = time;
                private _nuevoEstadoVuelo = call OPT_fnc_estaVolando;
                
                // Si el estado cambi√≥, procesar todas las entidades
                if (_nuevoEstadoVuelo != OPT_estaVolando) then {
                    OPT_estaVolando = _nuevoEstadoVuelo;
                    
                    // Reprocesar todas las entidades para actualizar visibilidad
                    {
                        if (!isNull _x && !isPlayer _x) then {
                            [_x] call OPT_fnc_procesarEntidad;
                        };
                    } forEach OPT_entidadesGestionadas;
                };
            };
            
            // Ocultar objetos lejanos
            call OPT_fnc_ocultarObjetosLejanos;
        };
        
        // Actualizar sector
        call OPT_fnc_obtenerSectorJugador;
        
        // Actualizar lista de jugadores (para comprobaciones de proximidad)
        OPT_todosJugadores = allPlayers - entities "HeadlessClient_F";
        
        // Gestionar nuevas entidades
        {
            if !(_x in OPT_entidadesGestionadas) then {
                if (!isPlayer _x) then {
                    [_x] call OPT_fnc_registrarEntidad;
                };
            };
        } forEach (allUnits + vehicles);
        
        // Eliminar entidades eliminadas de la lista
        OPT_entidadesGestionadas = OPT_entidadesGestionadas select {!isNull _x};
        
        // Limpiar eventos caducados
        if (time - OPT_ultimoEvento > 10) then {
            OPT_eventosImportantes = OPT_eventosImportantes select {(_x select 2) > time};
        };
        
        // Verificar si es momento de limpieza profunda
        if (time - OPT_ultimaLimpieza > 900) then { // Cada 15 minutos
            [] spawn OPT_fnc_limpiezaProfunda;
            OPT_ultimaLimpieza = time;
        };
    };
};

// üîÑ Bucle principal de optimizaci√≥n
OPT_fnc_bucleOptimizacion = {
    while {OPT_activo} do {
        // Comprobamos si hay que actualizar cach√©s
        call OPT_fnc_actualizarCache;
        
        // Procesar cad√°veres pendientes
        call OPT_fnc_procesarCadaveres;
        
        // Comprobar si el jugador se ha movido lo suficiente
        private _posJugador = if (OPT_enHeadless) then {
            missionNamespace getVariable ["OPT_posicionJugadorGlobal", [0,0,0]]
        } else {
            if (!isNull player) then {
                getPosATL player
            } else {
                [0,0,0]
            };
        };
        
        if (OPT_ultimaPosJugador distance _posJugador > OPT_distanciaMovimiento) then {
            OPT_ultimaPosJugador = _posJugador;
            
            // Forzar distancia de visi√≥n al moverse
            if (hasInterface && !isNull player) then {
                call OPT_fnc_forzarDistanciaVision;
            };
            
            // Procesar entidades prioritarias
            {
                if (_x distance _posJugador < OPT_radioSimulacion * 2) then {
                    [_x] call OPT_fnc_procesarEntidad;
                };
            } forEach OPT_entidadesGestionadas;
            
            // Procesar objetos decorativos cercanos con m√°s frecuencia
            if (OPT_optimizarDecoraciones) then {
                {
                    if (_x distance _posJugador < OPT_radioDecoraciones * 2) then {
                        [_x] call OPT_fnc_procesarEntidad;
                    };
                } forEach OPT_objetosPequenos;
            };
        };
        
        // Procesar un lote de entidades cada iteraci√≥n
        private _lote = floor(5 + (count OPT_entidadesGestionadas / 20)); // Cantidad adaptativa
        _lote = _lote min 25 max 5; // Entre 5 y 25 por ciclo
        
        private _procesados = 0;
        {
            // Entidades que han sido procesadas hace m√°s de 5 segundos
            if (time > (_x getVariable ["OPT_ultimoProcesado", 0]) + 5) then {
                // No procesar cad√°veres en periodo de ragdoll
                if !(_x in OPT_cadaveresPendientes) then {
                    [_x] call OPT_fnc_procesarEntidad;
                    _x setVariable ["OPT_ultimoProcesado", time];
                    _procesados = _procesados + 1;
                };
                
                // Limitar la cantidad por ciclo
                if (_procesados >= _lote) then {
                    // Salir del bucle
                };
            };
        } forEach OPT_entidadesGestionadas;
        
        sleep 0.1; // Ejecutar 10 veces por segundo es suficiente y menos costoso
    };
};

// üöó Funci√≥n para agregar evento de entrada/salida de veh√≠culo
OPT_fnc_agregarEventosVehiculo = {
    if (!hasInterface || isNull player) then {
        // Nada que hacer sin interfaz o jugador
    } else {
        player addEventHandler ["GetInMan", {
            params ["_unit", "_position", "_vehicle"];
            OPT_vehiculoActual = _vehicle;
            
            // Al entrar en veh√≠culo, aumentamos radio de simulaci√≥n
            OPT_radioSimulacion = OPT_radioSimulacionOriginal * 1.5;
        }];
        
        player addEventHandler ["GetOutMan", {
            params ["_unit", "_position", "_vehicle"];
            OPT_vehiculoActual = objNull;
            
            // Al salir del veh√≠culo, restauramos radio de simulaci√≥n original
            OPT_radioSimulacion = OPT_radioSimulacionOriginal;
        }];
        
        // Evento para armas, registra el evento importante
        player addEventHandler ["Fired", {
            params ["_unit", "_weapon", "_muzzle", "_mode", "_ammo", "_magazine", "_projectile", "_gunner"];
            
            // Solo para armas significativas
            if (_weapon != "Throw" && _weapon != "Put") then {
                // Radio y duraci√≥n proporcionales al calibre
                private _calibre = getNumber (configFile >> "CfgAmmo" >> _ammo >> "caliber");
                private _radio = 50 + (_calibre * 5);
                private _duracion = 5 + (_calibre * 0.5);
                
                // Registrar el evento
                [getPosATL _unit, _radio, _duracion] call OPT_fnc_registrarEvento;
            } else {
                // Para granadas y explosivos
                if (_ammo isKindOf "GrenadeBase" || _ammo isKindOf "TimeBombCore") then {
                    // Registrar evento con un retardo para la detonaci√≥n
                    [_projectile, _unit] spawn {
                        params ["_proyectil", "_unidad"];
                        private _posInicial = getPosATL _proyectil;
                        sleep 3; // Tiempo aproximado para detonaci√≥n
                        if (!isNull _proyectil) then {
                            [getPosATL _proyectil, 75, 15] call OPT_fnc_registrarEvento;
                        } else {
                            [_posInicial, 75, 15] call OPT_fnc_registrarEvento;
                        };
                    };
                };
            };
        }];
        
        // Registrar eventos de explosiones mediante el sistema de armas
        if (OPT_tieneACE) then {
            // Si usa ACE
            ["ace_explosives_detonated", {
                params ["_explosive"];
                private _position = getPosATL _explosive;
                [_position, 100, 20] call OPT_fnc_registrarEvento;
            }] call CBA_fnc_addEventHandler;
        };
        
        // A√±adir manejador de eventos para resistir intentos del jugador de cambiar la distancia
        (findDisplay 46) displayAddEventHandler ["KeyDown", {
            // Forzar vista cada vez que se presiona una tecla
            call OPT_fnc_forzarDistanciaVision;
            false
        }];
    };
};

// üîç Funci√≥n para detectar y registrar objetos decorativos
OPT_fnc_detectarDecoraciones = {
    if (!OPT_optimizarDecoraciones) then {
        // No hacer nada si no est√° activada la optimizaci√≥n
    } else {
        // Buscar decoraciones en el radio relevante
        private _posJugador = if (OPT_enHeadless) then {
            missionNamespace getVariable ["OPT_posicionJugadorGlobal", [0,0,0]]
        } else {
            if (!isNull player) then {
                getPosATL player
            } else {
                [0,0,0]
            };
        };
        
        private _objetosEncontrados = 0;
        {
            private _clase = _x;
            private _objetos = nearestObjects [_posJugador, [_clase], OPT_distanciaMaxima];
            
            {
                if !(_x in OPT_entidadesGestionadas) then {
                    if (!isPlayer _x) then {
                        [_x] call OPT_fnc_registrarEntidad;
                        _objetosEncontrados = _objetosEncontrados + 1;
                    };
                };
            } forEach _objetos;
        } forEach OPT_clasesDecorativas;
        
        // Programar pr√≥xima b√∫squeda
        if (OPT_tieneCBA) then {
            [OPT_fnc_detectarDecoraciones, [], 60] call CBA_fnc_waitAndExecute;
        } else {
            [] spawn {
                sleep 60;
                call OPT_fnc_detectarDecoraciones;
            };
        };
    };
};

// ===== INICIALIZACI√ìN AUTOM√ÅTICA =====
OPT_fnc_inicializar = {
    // Guardar valor original del radio de simulaci√≥n
    OPT_radioSimulacionOriginal = OPT_radioSimulacion;
    
    // Si es un headless client, comportamiento especial
    if (OPT_enHeadless) then {
        OPT_radioSimulacion = OPT_radioSimulacion * 0.8;
        OPT_intervaloCacheado = 8;
        
        // Sincronizar posici√≥n del jugador desde el servidor
        OPT_ultimaPosJugador = [0,0,0];
    };
    
    // Guardar configuraci√≥n original de vista
    if (hasInterface) then {
        // Guardar valores originales
        OPT_viewDistanciaOriginal = viewDistance;
        OPT_objectViewDistanciaOriginal = getObjectViewDistance;
    };
    
    // Forzar configuraci√≥n de visi√≥n de inmediato si es posible
    if (hasInterface && !isNull player) then {
        // Forzar la distancia inmediatamente
        setViewDistance OPT_distanciaVisionForzada;
        setObjectViewDistance OPT_distanciaVisionForzada;
        
        // Notificar al jugador
        systemChat "";
        
        // Iniciar bucle para garantizar que se mantiene
        [] spawn {
            while {OPT_activo} do {
                setViewDistance OPT_distanciaVisionForzada;
                setObjectViewDistance OPT_distanciaVisionForzada;
                sleep 1;
            };
        };
    };
    
    // Activar el procesamiento del l√≠mite de visibilidad
    OPT_procesarLimiteVisibilidad = true;
    
    // Generar sectores del mapa
    call OPT_fnc_generarSectores;
    
    // Inicializar variables
    OPT_ultimaPosJugador = if (OPT_enHeadless) then {
        [0,0,0]
    } else {
        if (!isNull player) then {
            getPosATL player
        } else {
            [0,0,0]
        };
    };
    
    // Inicializar estado de vuelo
    if (hasInterface && !isNull player) then {
        OPT_estaVolando = call OPT_fnc_estaVolando;
    };
    
    // Inicializar lista de jugadores
    OPT_todosJugadores = allPlayers - entities "HeadlessClient_F";
    
    // Inicializar otras variables
    OPT_vehiculoActual = objNull;
    OPT_cadaveresPendientes = [];
    OPT_objetosPequenos = [];
    OPT_objetosLejanos = [];
    
    // Registrar eventos de veh√≠culo y otros eventos
    call OPT_fnc_agregarEventosVehiculo;
    
    // Registrar unidades iniciales
    {
        if (OPT_optimizarIA && {_x isKindOf "CAManBase"} && {!isPlayer _x}) then {
            [_x] call OPT_fnc_registrarEntidad;
        };
    } forEach allUnits;
    
    // Registrar veh√≠culos iniciales
    if (OPT_optimizarVehiculos) then {
        {
            if (_x isKindOf "AllVehicles" && {!(_x isKindOf "CAManBase")}) then {
                [_x] call OPT_fnc_registrarEntidad;
            };
        } forEach vehicles;
    };
    
    // Registrar objetos est√°ticos si est√° activado
    if (OPT_optimizarObjetos) then {
        {
            if (_x isKindOf "Static" && {!(_x in OPT_entidadesGestionadas)}) then {
                [_x] call OPT_fnc_registrarEntidad;
            };
        } forEach (allMissionObjects "Static");
    };
    
    // Registrar objetos decorativos
    if (OPT_optimizarDecoraciones) then {
        call OPT_fnc_detectarDecoraciones;
    };
    
    // Iniciar bucle de optimizaci√≥n
    [] spawn OPT_fnc_bucleOptimizacion;
};

// ===== EVENTO TERMINAR MISION =====
addMissionEventHandler ["Ended", {
    if (OPT_activo) then {
        // Restaurar todas las entidades
        {
            if (!isNull _x) then {
                _x enableSimulationGlobal true;
                _x hideObjectGlobal false;
                
                if (_x isKindOf "CAManBase" && {!isPlayer _x}) then {
                    _x enableAI "PATH";
                    _x enableAI "FSM";
                    _x enableAI "TARGET";
                };
            };
        } forEach OPT_entidadesGestionadas;
        
        // Restaurar vista original si es necesario
        if (hasInterface && !isNull player) then {
            // Restaurar vista completa correctamente
            setViewDistance OPT_viewDistanciaOriginal;
            // Restaurar el array completo correctamente
            setObjectViewDistance (OPT_objectViewDistanciaOriginal select 0);
        };
        
        // Limpiar arrays
        OPT_entidadesGestionadas = [];
        OPT_cadaveresPendientes = [];
        OPT_objetosPequenos = [];
        OPT_eventosImportantes = [];
        OPT_objetosLejanos = [];
        
        // Desactivar script
        OPT_activo = false;
    };
}];

// ===== INICIALIZACI√ìN AUTOM√ÅTICA =====
[] spawn {
    waitUntil {!isNil "bis_fnc_init"};
    call OPT_fnc_inicializar;
};
